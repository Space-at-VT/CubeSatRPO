
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>newSatellite</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-09-25"><meta name="DC.source" content="newSatellite.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">New Satellite</a></li><li><a href="#2">Default properties of a basic 6u cubesat</a></li><li><a href="#3">Graphics</a></li><li><a href="#4">Satellite parameters</a></li><li><a href="#5">Trajectory</a></li><li><a href="#6">Attitude</a></li><li><a href="#7">Debug</a></li><li><a href="#10">Basic point to point movement with collision avoidance</a></li><li><a href="#11">Hold within a certain zone</a></li><li><a href="#14">Convert solver signals to propagation</a></li><li><a href="#15">Propagate trajectory with no fuel</a></li><li><a href="#16">Propagate attitude</a></li></ul></div><h2>New Satellite<a name="1"></a></h2><p>Translational trajcetory generation is all the same as the summer. Organized to be more easily commanded. All attitude modeling is still in development. Basic damping and PD in included for perturbations caused from the off-centering of thrusters. As of 9/8 the model is not coupled with translational movement. The linearity of the model may limit the accuracy of coupling rotation with translation.</p><pre class="codeinput"><span class="keyword">classdef</span> newSatellite
</pre><h2>Default properties of a basic 6u cubesat<a name="2"></a></h2><pre class="codeinput">    properties
</pre><h2>Graphics<a name="3"></a></h2><pre class="codeinput">        name = <span class="string">'CubeSat'</span>            <span class="comment">%Satellite name</span>
        EOM = <span class="string">'HCW'</span>                 <span class="comment">%Relative motion model</span>
        mode = <span class="string">'approach'</span>           <span class="comment">%Satellite objective</span>
        color = <span class="string">'b'</span>                 <span class="comment">%Graph color</span>
</pre><h2>Satellite parameters<a name="4"></a></h2><pre class="codeinput">        umax = 0.25                 <span class="comment">%Thrust,                N</span>
        ISP = 150                   <span class="comment">%Specific impulse,      s</span>
        dryMass = 13                <span class="comment">%Dry mass,              kg</span>
        fuel = 0.5                  <span class="comment">%Fuel mass,             kg</span>
        vmax = 0.5                  <span class="comment">%Max velocity,          m/s</span>
        bnd = [0.1,0.3,0.2]         <span class="comment">%Satellite size,        m</span>
        Tmax = 0.25                 <span class="comment">%Max reaction torque</span>
        kp = 0.1                    <span class="comment">%Position damping</span>
        kd = 0.7                    <span class="comment">%Velocity damping</span>
        ki = 0.3                    <span class="comment">%Integral damping</span>
        d = [0.01,0.01,0.01]        <span class="comment">%Thruster misalignment</span>
                                    <span class="comment">% moment arm,           m</span>
</pre><h2>Trajectory<a name="5"></a></h2><pre class="codeinput">        x = 0                       <span class="comment">%x position over time,  m</span>
        y = 0                       <span class="comment">%y position over time,  m</span>
        z = 0                       <span class="comment">%z position over time,  m</span>
        vx = 0                      <span class="comment">%x velocity over time,  m/s</span>
        vy = 0                      <span class="comment">%y velocity over time,  m/s</span>
        vz = 0                      <span class="comment">%z velocity over time,  m/s</span>
        ux = []                     <span class="comment">%x thrust over time,    N</span>
        uy = []                     <span class="comment">%y thrust over time,    N</span>
        uz = []                     <span class="comment">%z thrust over time,    N</span>
        T1 = []                     <span class="comment">%x reaction torque,     N*m</span>
        T2 = []                     <span class="comment">%y reaction torque,     N*m</span>
        T3 = []                     <span class="comment">%z reaction torque,     N*m</span>
</pre><h2>Attitude<a name="6"></a></h2><pre class="codeinput">        wb1 = 0                     <span class="comment">%Angular velocity       rad/s</span>
        wb2 = 0                     <span class="comment">%over time,             rad/s</span>
        wb3 = 0                     <span class="comment">%                       rad/s</span>
<span class="comment">%         th1 = 0                   %Euler Angles           rad</span>
<span class="comment">%         th2 = 0                   %                       rad</span>
<span class="comment">%         th3 = 0                   %                       rad</span>
        q1 = 0                      <span class="comment">%Quaternions</span>
        q2 = 0
        q3 = 0
        q4 = 1;

        point = 0                   <span class="comment">%Attitude pointing y/n, binary</span>
        pt = [0,0,0]                <span class="comment">%Attitude point target, m</span>
</pre><h2>Debug<a name="7"></a></h2><pre class="codeinput">        flag = []                   <span class="comment">%Exit flag</span>
        makeMovie = 0;              <span class="comment">%Save movie struct</span>
        vid
        frames
</pre><pre class="codeinput">    <span class="keyword">end</span>
    properties (Dependent)
        m                           <span class="comment">%Total mass,            kg</span>
        mdot                        <span class="comment">%Mass flow rate,        kg/s</span>
        p                           <span class="comment">%Position vector,       m</span>
        v                           <span class="comment">%Velocity vector,       m/s</span>
        w                           <span class="comment">%Angular velocity,      rad/s</span>
        qb                          <span class="comment">%Quaternions vector,</span>
        Rib                         <span class="comment">%Rotation matrix b2i</span>
        Rbi                         <span class="comment">%Rotation matrix i2b</span>
        ubnd                        <span class="comment">%Upper bound,           m</span>
        lbnd                        <span class="comment">%Lower bound,           m</span>
        I                           <span class="comment">%Moments of Inertia,    kg/m^2</span>

    <span class="keyword">end</span>
    methods
</pre><pre class="codeinput">        <span class="comment">% Constructor</span>
        <span class="keyword">function</span> obj = satellite(umax,ISP,dryMass,fuel)
            <span class="keyword">if</span> nargin &gt; 0
                obj.umax = umax;
                obj.ISP = ISP;
                obj.dryMass = dryMass;
                obj.fuel = fuel;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Total mass (Dependent)</span>
        <span class="keyword">function</span> m = get.m(obj)
            m = obj.fuel+obj.dryMass;
        <span class="keyword">end</span>
        <span class="comment">% Mass flow rate (Dependent)</span>
        <span class="keyword">function</span> mdot = get.mdot(obj)
            mdot = 1/obj.ISP/9.81;
        <span class="keyword">end</span>
        <span class="comment">% Current position vector</span>
        <span class="keyword">function</span> p = get.p(obj)
            p = [obj.x(end),obj.y(end),obj.z(end)];
        <span class="keyword">end</span>
        <span class="comment">% Current velocity vector</span>
        <span class="keyword">function</span> v = get.v(obj)
            v = [obj.vx(end),obj.vy(end),obj.vz(end)];
        <span class="keyword">end</span>
        <span class="comment">% Current body-frame angular velocity</span>
        <span class="keyword">function</span> w = get.w(obj)
            w = [obj.wb1(end),obj.wb2(end),obj.wb3(end)]';
        <span class="keyword">end</span>
        <span class="comment">% Current quaternions</span>
        <span class="keyword">function</span> qb = get.qb(obj)
            qb = [obj.q1(end),obj.q2(end),obj.q3(end),obj.q4(end)]';
        <span class="keyword">end</span>
        <span class="comment">% Current intertial to body rotation matrix</span>
        <span class="keyword">function</span> Rbi = get.Rbi(obj)
            q = obj.qb(1:3);
            q4 = obj.qb(4);
            qx = [0 -q(3) q(2)
                q(3) 0 -q(1)
                -q(2) q(1) 0];
            Rbi = (q4^2-q'*q)*eye(3)+2*(q*q')-2*q4*qx;
        <span class="keyword">end</span>
        <span class="comment">% Current body to inertial rotation matrix</span>
        <span class="keyword">function</span> Rib = get.Rib(obj)
            Rib = inv(obj.Rbi);
        <span class="keyword">end</span>
        <span class="comment">% Satellite body upper bound</span>
        <span class="keyword">function</span> ubnd = get.ubnd(obj)
            ubnd = obj.bnd/2;
        <span class="keyword">end</span>
        <span class="comment">% Satellite body lower lound</span>
        <span class="keyword">function</span> lbnd = get.lbnd(obj)
            lbnd = -obj.bnd/2;
        <span class="keyword">end</span>
        <span class="comment">% Satellite moment of inertia vector</span>
        <span class="keyword">function</span> I = get.I(obj)
            I(1) = 1/12*obj.m*(obj.bnd(2)^2+obj.bnd(3)^2);
            I(2) = 1/12*obj.m*(obj.bnd(1)^2+obj.bnd(3)^2);
            I(3) = 1/12*obj.m*(obj.bnd(1)^2+obj.bnd(2)^2);
        <span class="keyword">end</span>
        <span class="comment">% Video making functions</span>
        <span class="keyword">function</span> sat = addFrame(sat,fig)
            iter = length(sat.frames);
            sat.frames = getframe(fig);

        <span class="keyword">end</span>
        <span class="keyword">function</span> sat = renderFrames(sat)
            sat.vid = VideoWriter(sat.name);
            open(sat.vid);
            <span class="keyword">for</span> ii = 1:length(sat.frames)
                writeVideo(sat.vid,sat.frames(ii))
            <span class="keyword">end</span>
            close(sat.vid);
        <span class="keyword">end</span>
</pre><h2>Basic point to point movement with collision avoidance<a name="10"></a></h2><pre class="codeinput">        <span class="keyword">function</span> sat = approach(sat,scenario,p,lbnd,ubnd)
            <span class="keyword">if</span> nargin &lt; 4 || isempty(lbnd)
                lbnd = [];
                ubnd = [];
            <span class="keyword">end</span>
            <span class="keyword">if</span> sat.fuel &gt; 0
                w1 = 1e-1; <span class="comment">%Thrust</span>
                w2 = 1;    <span class="comment">%Targeting</span>
                Nvar = scenario.Nvar;
                Neom = scenario.Neom;
                scenario.Nobj = size(lbnd,1);
                Nbi = scenario.Nbi;
                Ntotal = scenario.Ntotal;

                <span class="comment">% Function coefficients</span>
                f = [w1*scenario.dt*ones(Nvar,1); <span class="comment">%Control thrusts</span>
                    zeros(Neom,1);       <span class="comment">%HCW accelerations</span>
                    w2*ones(3,1);        <span class="comment">%Target distance</span>
                    zeros(Nbi,1)];       <span class="comment">%Collision avoidance</span>

                <span class="comment">% Parameter bounds, lower &amp; upper</span>
                lb = [zeros(Nvar,1);   <span class="comment">%Control thrusts</span>
                    -inf*ones(Neom,1); <span class="comment">%HCW accelerations</span>
                    zeros(3,1);        <span class="comment">%Target distance</span>
                    zeros(Nbi,1)];     <span class="comment">%Collision avoidance</span>

                ub = [ones(Nvar,1);   <span class="comment">%Control thrusts</span>
                    inf*ones(Neom,1); <span class="comment">%HCW accelerations</span>
                    inf*ones(3,1);    <span class="comment">%Target distance</span>
                    ones(Nbi,1)];     <span class="comment">%Collision avoidance</span>

                <span class="comment">% Integer constraints</span>
                intcon = [1:Nvar,Nvar+Neom+3+1:Ntotal];

                <span class="comment">% Equality contraints</span>
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario);

                <span class="comment">% Inequality contraints</span>
                A = [];   b = [];
                [A,b] = minDistance(A,b,sat,scenario,p);
                [A,b] = maxVelocity(A,b,sat,scenario);

                <span class="keyword">for</span> ii = 1:size(lbnd,1)
                    [A,b] = addObstacle(A,b,sat,scenario,lbnd(ii,:),ubnd(ii,:),ii);
                <span class="keyword">end</span>

                options = optimoptions(@intlinprog,<span class="string">'Display'</span>,<span class="string">'None'</span>,<span class="string">'MaxTime'</span>,1);
                [u,~,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub,options);

                sat = signalsProp(sat,scenario,u,exitflag);
            <span class="keyword">else</span>
                sat = driftProp(sat,scenario);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>Hold within a certain zone<a name="11"></a></h2><pre class="codeinput">        <span class="keyword">function</span> sat = maintain(sat,scenario,lbnd,ubnd)
            <span class="keyword">if</span> sat.fuel &gt; 0
                Nvar = scenario.Nvar;
                Neom = scenario.Neom;

                <span class="comment">% Function coefficients</span>
                f = [scenario.dt*ones(Nvar,1);  <span class="comment">%Control thrusts</span>
                     zeros(Neom,1)              <span class="comment">%HCW accelerations</span>
                     zeros(3,1)];               <span class="comment">%Target distance</span>

                <span class="comment">% Parameter bounds, lower &amp; upper</span>
                lb = [zeros(Nvar,1);            <span class="comment">%Control thrusts</span>
                    -inf*ones(Neom,1)           <span class="comment">%HCW accelerations</span>
                     zeros(3,1)];

                ub = [ones(Nvar,1);             <span class="comment">%Control thrusts</span>
                     inf*ones(Neom,1)           <span class="comment">%HCW accelerations</span>
                     ones(3,1)];

                <span class="comment">% Integer constraints</span>
                intcon = 1:Nvar;

                <span class="comment">% Equality contraints</span>
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario);

                <span class="comment">% Inequality contraints</span>
                A = [];   b = [];
                [A,b] = holdProximity(A,b,sat,scenario,lbnd,ubnd);
                [A,b] = maxVelocity(A,b,sat,scenario);

                options = optimoptions(@intlinprog,<span class="string">'Display'</span>,<span class="string">'None'</span>,<span class="string">'MaxTime'</span>,1);
                [u,~,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub,options);

                sat = signalsProp(sat,scenario,u,exitflag);
            <span class="keyword">else</span>
                sat = driftProp(sat,scenario);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2>Convert solver signals to propagation<a name="14"></a></h2><pre class="codeinput"><span class="keyword">function</span> sat = signalsProp(sat,scenario,u,exitflag)
Nvar = scenario.Nvar;
iter = length(sat.x);

<span class="comment">% Solver exit flag</span>
sat.flag(iter) = exitflag;

<span class="comment">% Control signals</span>
u = round(u);
sat.ux(iter) = sat.umax*(u(1)-u(2));
sat.uy(iter) = sat.umax*(u(3)-u(4));
sat.uz(iter) = sat.umax*(u(5)-u(6));
ax = u(Nvar+1);
ay = u(Nvar+2);
az = u(Nvar+3);

<span class="comment">% New velocity</span>
dt = scenario.dt;
sat.vx(iter+1) = sat.vx(iter)+(sat.ux(iter)/sat.m+ax)*dt;
sat.vy(iter+1) = sat.vy(iter)+(sat.uy(iter)/sat.m+ay)*dt;
sat.vz(iter+1) = sat.vz(iter)+(sat.uz(iter)/sat.m+az)*dt;

<span class="comment">% New position</span>
sat.x(iter+1) = sat.x(iter)+sat.vx(iter)*dt;
sat.y(iter+1) = sat.y(iter)+sat.vy(iter)*dt;
sat.z(iter+1) = sat.z(iter)+sat.vz(iter)*dt;

<span class="comment">% Resize control vector</span>
sat.ux(iter+1) = 0;
sat.uy(iter+1) = 0;
sat.uz(iter+1) = 0;

<span class="comment">% Propagate attitude</span>
sat = attitudeProp(sat,scenario);

<span class="comment">% Fuel mass loss</span>
sat.fuel = sat.fuel-sum(u(1:6))*sat.umax*sat.mdot;
<span class="keyword">end</span>
</pre><h2>Propagate trajectory with no fuel<a name="15"></a></h2><pre class="codeinput"><span class="keyword">function</span> sat = driftProp(sat,scenario)
dt = scenario.dt;

<span class="comment">% Switch equations of motion model state matrix</span>
<span class="keyword">switch</span> sat.EOM
    <span class="keyword">case</span> <span class="string">'HCW'</span>
        A = HCW(scenario);
    <span class="keyword">case</span> <span class="string">'LERM'</span>
        A = LERM(scenario);
<span class="keyword">end</span>

<span class="comment">% Calculate new state</span>
iter = length(sat.x);
X = [sat.x(iter),sat.y(iter),sat.z(iter),<span class="keyword">...</span>
    sat.vx(iter),sat.vy(iter),sat.vz(iter)]';
DX = A*X;

<span class="comment">% Control signals - all off</span>
sat.ux(iter) = 0;
sat.uy(iter) = 0;
sat.uz(iter) = 0;

<span class="comment">% New velocity</span>
sat.vx(iter+1) = sat.vx(iter)+DX(4)*dt;
sat.vy(iter+1) = sat.vy(iter)+DX(5)*dt;
sat.vz(iter+1) = sat.vz(iter)+DX(6)*dt;

<span class="comment">% New position</span>
sat.x(iter+1) = sat.x(iter)+sat.vx(iter)*dt;
sat.y(iter+1) = sat.y(iter)+sat.vy(iter)*dt;
sat.z(iter+1) = sat.z(iter)+sat.vz(iter)*dt;

<span class="comment">% Prop attitude</span>
sat = attitudeProp(sat,scenario);

<span class="comment">% Update control vector</span>
sat.ux(iter+1) = 0;
sat.uy(iter+1) = 0;
sat.uz(iter+1) = 0;

<span class="comment">% Debug flag</span>
sat.flag(iter) = 3;
<span class="keyword">end</span>
</pre><h2>Propagate attitude<a name="16"></a></h2><pre class="codeinput"><span class="keyword">function</span> sat = attitudeProp(sat,scenario)
<span class="comment">% Reaction wheel torques</span>
iter = length(sat.q1);
dt = scenario.dt;

<span class="comment">% Still in progress - use PD contorolled reaction wheel torques to point</span>
<span class="comment">% satellite at user-defined point.</span>
<span class="comment">% Else the satellite just minimizes divergence from the inertial axes.</span>
<span class="keyword">if</span> sat.point
<span class="comment">%     vt = (sat.pt-sat.p)/norm(sat.pt-sat.p);</span>
<span class="comment">%     th3 = atan2(vt(2),vt(1));</span>
<span class="comment">%     th2 = atan2(vt(3),norm([vt(1),vt(2)]));</span>
<span class="comment">%     R = rot(th2,2)*rot(th3,3);</span>
<span class="comment">%     q4t = 1/2*sqrt(1+trace(R));</span>
<span class="comment">%     qt = 1/4/q4t*[R(2,3)-R(3,2);R(3,1)-R(1,3);R(1,2)-R(2,1)];</span>
<span class="comment">%</span>
<span class="comment">%     Tx = -sat.kp*(sat.q1(iter)-qt(1))-sat.kd*sat.wb1(iter);</span>
<span class="comment">%     Ty = -sat.kp*(sat.q2(iter)-qt(2))-sat.kd*sat.wb2(iter);</span>
<span class="comment">%     Tz = -sat.kp*(sat.q3(iter)-qt(3))-sat.kd*sat.wb3(iter);</span>
<span class="keyword">else</span>
    sat.T1(iter) = -sat.kp*(sat.q1(iter))-sat.kd*sat.wb1(iter);
    sat.T2(iter) = -sat.kp*(sat.q2(iter))-sat.kd*sat.wb2(iter);
    sat.T3(iter) = -sat.kp*(sat.q3(iter))-sat.kd*sat.wb3(iter);
    sat.T1(iter+1) = 0;
    sat.T2(iter+1) = 0;
    sat.T3(iter+1) = 0;
<span class="keyword">end</span>

<span class="comment">% Ensure torques are below max capable torque</span>
<span class="keyword">if</span> sat.T1(iter) &gt; sat.Tmax,   sat.T1(iter) = sat.Tmax;  <span class="keyword">end</span>
<span class="keyword">if</span> sat.T1(iter) &lt; -sat.Tmax,  sat.T1(iter) = -sat.Tmax; <span class="keyword">end</span>
<span class="keyword">if</span> sat.T2(iter) &gt; sat.Tmax,   sat.T2(iter) = sat.Tmax;  <span class="keyword">end</span>
<span class="keyword">if</span> sat.T2(iter) &lt; -sat.Tmax,  sat.T2(iter) = -sat.Tmax; <span class="keyword">end</span>
<span class="keyword">if</span> sat.T3(iter) &gt; sat.Tmax,   sat.T3(iter) = sat.Tmax;  <span class="keyword">end</span>
<span class="keyword">if</span> sat.T3(iter) &lt; -sat.Tmax,  sat.T3(iter) = -sat.Tmax; <span class="keyword">end</span>

<span class="comment">% Total applied torque with thruster offset moment</span>
M(1) = sat.uz(iter)*sat.d(2)-sat.uy(iter)*sat.d(3)+sat.T1(iter);
M(2) = sat.ux(iter)*sat.d(3)-sat.uz(iter)*sat.d(1)+sat.T2(iter);
M(3) = sat.uy(iter)*sat.d(1)-sat.ux(iter)*sat.d(2)+sat.T3(iter);

<span class="comment">% New angular velocity</span>
I = sat.I;
w = sat.w;
sat.wb1(iter+1) = sat.wb1(iter)+((I(2)-I(3))/I(1)*w(2)*w(3)+M(1)/I(1))*dt;
sat.wb2(iter+1) = sat.wb2(iter)+((I(3)-I(1))/I(2)*w(1)*w(3)+M(2)/I(2))*dt;
sat.wb3(iter+1) = sat.wb3(iter)+((I(1)-I(2))/I(3)*w(1)*w(2)+M(3)/I(3))*dt;

<span class="comment">% Unused, could be defined as euler angles if needed</span>
<span class="comment">% sat.th1(iter+1) = sat.th1(iter)+sat.wb1(iter)*dt;</span>
<span class="comment">% sat.th2(iter+1) = sat.th2(iter)+sat.wb2(iter)*dt;</span>
<span class="comment">% sat.th3(iter+1) = sat.th3(iter)+sat.wb3(iter)*dt;</span>

<span class="comment">% Solve for quaternion rate of change</span>
q = sat.qb(1:3);
q4 = sat.qb(4);
qx = [0   -q(3) q(2)
      q(3) 0   -q(1)
     -q(2) q(1) 0];
dqdt = 1/2*[qx+q4*eye(3);-q']*w;

<span class="comment">% Normalize quaternions to account for numerical error (Ensures quaternions</span>
<span class="comment">% don't diverge to unreal values.</span>
qb = sat.qb+dqdt*dt;
qb = qb/norm(qb);

<span class="comment">% New quaternions</span>
sat.q1(iter+1) = qb(1);
sat.q2(iter+1) = qb(2);
sat.q3(iter+1) = qb(3);
sat.q4(iter+1) = qb(4);
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% New Satellite
% Translational trajcetory generation is all the same as the summer.
% Organized to be more easily commanded. All attitude modeling is still in
% development. Basic damping and PD in included for perturbations caused
% from the off-centering of thrusters. As of 9/8 the model is not coupled
% with translational movement. The linearity of the model may limit the
% accuracy of coupling rotation with translation.

classdef newSatellite   
    %% Default properties of a basic 6u cubesat
    properties
        %% Graphics
        name = 'CubeSat'            %Satellite name
        EOM = 'HCW'                 %Relative motion model
        mode = 'approach'           %Satellite objective
        color = 'b'                 %Graph color
        
        %% Satellite parameters
        umax = 0.25                 %Thrust,                N
        ISP = 150                   %Specific impulse,      s
        dryMass = 13                %Dry mass,              kg
        fuel = 0.5                  %Fuel mass,             kg
        vmax = 0.5                  %Max velocity,          m/s
        bnd = [0.1,0.3,0.2]         %Satellite size,        m
        Tmax = 0.25                 %Max reaction torque
        kp = 0.1                    %Position damping
        kd = 0.7                    %Velocity damping
        ki = 0.3                    %Integral damping
        d = [0.01,0.01,0.01]        %Thruster misalignment
                                    % moment arm,           m
               
        %% Trajectory
        x = 0                       %x position over time,  m
        y = 0                       %y position over time,  m
        z = 0                       %z position over time,  m
        vx = 0                      %x velocity over time,  m/s
        vy = 0                      %y velocity over time,  m/s
        vz = 0                      %z velocity over time,  m/s
        ux = []                     %x thrust over time,    N
        uy = []                     %y thrust over time,    N
        uz = []                     %z thrust over time,    N
        T1 = []                     %x reaction torque,     N*m
        T2 = []                     %y reaction torque,     N*m
        T3 = []                     %z reaction torque,     N*m
        
        %% Attitude
        wb1 = 0                     %Angular velocity       rad/s
        wb2 = 0                     %over time,             rad/s
        wb3 = 0                     %                       rad/s
%         th1 = 0                   %Euler Angles           rad
%         th2 = 0                   %                       rad   
%         th3 = 0                   %                       rad
        q1 = 0                      %Quaternions
        q2 = 0
        q3 = 0
        q4 = 1;

        point = 0                   %Attitude pointing y/n, binary
        pt = [0,0,0]                %Attitude point target, m
        
        %% Debug
        flag = []                   %Exit flag
        makeMovie = 0;              %Save movie struct
        vid
        frames  
        
    end
    properties (Dependent)
        m                           %Total mass,            kg
        mdot                        %Mass flow rate,        kg/s
        p                           %Position vector,       m
        v                           %Velocity vector,       m/s
        w                           %Angular velocity,      rad/s
        qb                          %Quaternions vector,
        Rib                         %Rotation matrix b2i
        Rbi                         %Rotation matrix i2b
        ubnd                        %Upper bound,           m
        lbnd                        %Lower bound,           m
        I                           %Moments of Inertia,    kg/m^2 
        
    end
    methods
        % Constructor
        function obj = satellite(umax,ISP,dryMass,fuel)
            if nargin > 0
                obj.umax = umax;
                obj.ISP = ISP;
                obj.dryMass = dryMass;
                obj.fuel = fuel;
            end
        end
        
        % Total mass (Dependent)
        function m = get.m(obj)
            m = obj.fuel+obj.dryMass;
        end
        % Mass flow rate (Dependent)
        function mdot = get.mdot(obj)
            mdot = 1/obj.ISP/9.81;
        end
        % Current position vector
        function p = get.p(obj)
            p = [obj.x(end),obj.y(end),obj.z(end)];
        end
        % Current velocity vector
        function v = get.v(obj)
            v = [obj.vx(end),obj.vy(end),obj.vz(end)];
        end
        % Current body-frame angular velocity
        function w = get.w(obj)
            w = [obj.wb1(end),obj.wb2(end),obj.wb3(end)]';
        end
        % Current quaternions
        function qb = get.qb(obj)
            qb = [obj.q1(end),obj.q2(end),obj.q3(end),obj.q4(end)]';
        end
        % Current intertial to body rotation matrix
        function Rbi = get.Rbi(obj)
            q = obj.qb(1:3);
            q4 = obj.qb(4);
            qx = [0 -q(3) q(2)
                q(3) 0 -q(1)
                -q(2) q(1) 0];
            Rbi = (q4^2-q'*q)*eye(3)+2*(q*q')-2*q4*qx;
        end
        % Current body to inertial rotation matrix
        function Rib = get.Rib(obj)
            Rib = inv(obj.Rbi);
        end
        % Satellite body upper bound
        function ubnd = get.ubnd(obj)
            ubnd = obj.bnd/2;
        end
        % Satellite body lower lound
        function lbnd = get.lbnd(obj)
            lbnd = -obj.bnd/2;
        end
        % Satellite moment of inertia vector
        function I = get.I(obj)
            I(1) = 1/12*obj.m*(obj.bnd(2)^2+obj.bnd(3)^2);
            I(2) = 1/12*obj.m*(obj.bnd(1)^2+obj.bnd(3)^2);
            I(3) = 1/12*obj.m*(obj.bnd(1)^2+obj.bnd(2)^2);
        end     
        % Video making functions
        function sat = addFrame(sat,fig)
            iter = length(sat.frames);
            sat.frames = getframe(fig);
            
        end
        function sat = renderFrames(sat)
            sat.vid = VideoWriter(sat.name);
            open(sat.vid);
            for ii = 1:length(sat.frames)
                writeVideo(sat.vid,sat.frames(ii))
            end
            close(sat.vid);            
        end
        
        %% Basic point to point movement with collision avoidance
        function sat = approach(sat,scenario,p,lbnd,ubnd)
            if nargin < 4 || isempty(lbnd)
                lbnd = [];
                ubnd = [];
            end
            if sat.fuel > 0
                w1 = 1e-1; %Thrust
                w2 = 1;    %Targeting
                Nvar = scenario.Nvar;
                Neom = scenario.Neom;
                scenario.Nobj = size(lbnd,1);
                Nbi = scenario.Nbi;
                Ntotal = scenario.Ntotal;
                
                % Function coefficients
                f = [w1*scenario.dt*ones(Nvar,1); %Control thrusts
                    zeros(Neom,1);       %HCW accelerations
                    w2*ones(3,1);        %Target distance
                    zeros(Nbi,1)];       %Collision avoidance
                
                % Parameter bounds, lower & upper
                lb = [zeros(Nvar,1);   %Control thrusts
                    -inf*ones(Neom,1); %HCW accelerations
                    zeros(3,1);        %Target distance
                    zeros(Nbi,1)];     %Collision avoidance
                
                ub = [ones(Nvar,1);   %Control thrusts
                    inf*ones(Neom,1); %HCW accelerations
                    inf*ones(3,1);    %Target distance
                    ones(Nbi,1)];     %Collision avoidance
                
                % Integer constraints
                intcon = [1:Nvar,Nvar+Neom+3+1:Ntotal];
                
                % Equality contraints
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario);
                
                % Inequality contraints
                A = [];   b = [];
                [A,b] = minDistance(A,b,sat,scenario,p);
                [A,b] = maxVelocity(A,b,sat,scenario);
                
                for ii = 1:size(lbnd,1)
                    [A,b] = addObstacle(A,b,sat,scenario,lbnd(ii,:),ubnd(ii,:),ii);
                end

                options = optimoptions(@intlinprog,'Display','None','MaxTime',1);
                [u,~,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub,options);
                
                sat = signalsProp(sat,scenario,u,exitflag);
            else
                sat = driftProp(sat,scenario);
            end
        end
        
        %% Hold within a certain zone
        function sat = maintain(sat,scenario,lbnd,ubnd)
            if sat.fuel > 0
                Nvar = scenario.Nvar;
                Neom = scenario.Neom;
                
                % Function coefficients
                f = [scenario.dt*ones(Nvar,1);  %Control thrusts
                     zeros(Neom,1)              %HCW accelerations
                     zeros(3,1)];               %Target distance
                
                % Parameter bounds, lower & upper
                lb = [zeros(Nvar,1);            %Control thrusts
                    -inf*ones(Neom,1)           %HCW accelerations
                     zeros(3,1)];
                
                ub = [ones(Nvar,1);             %Control thrusts
                     inf*ones(Neom,1)           %HCW accelerations
                     ones(3,1)];    
                 
                % Integer constraints
                intcon = 1:Nvar;
                
                % Equality contraints
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario);
                
                % Inequality contraints
                A = [];   b = [];
                [A,b] = holdProximity(A,b,sat,scenario,lbnd,ubnd);
                [A,b] = maxVelocity(A,b,sat,scenario);
                
                options = optimoptions(@intlinprog,'Display','None','MaxTime',1);
                [u,~,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub,options);
                
                sat = signalsProp(sat,scenario,u,exitflag);
            else
                sat = driftProp(sat,scenario);
            end
        end
    end
end

%% Convert solver signals to propagation
function sat = signalsProp(sat,scenario,u,exitflag)
Nvar = scenario.Nvar;
iter = length(sat.x);

% Solver exit flag
sat.flag(iter) = exitflag;

% Control signals
u = round(u);
sat.ux(iter) = sat.umax*(u(1)-u(2));
sat.uy(iter) = sat.umax*(u(3)-u(4));
sat.uz(iter) = sat.umax*(u(5)-u(6));
ax = u(Nvar+1);
ay = u(Nvar+2);
az = u(Nvar+3);

% New velocity
dt = scenario.dt;
sat.vx(iter+1) = sat.vx(iter)+(sat.ux(iter)/sat.m+ax)*dt;
sat.vy(iter+1) = sat.vy(iter)+(sat.uy(iter)/sat.m+ay)*dt;
sat.vz(iter+1) = sat.vz(iter)+(sat.uz(iter)/sat.m+az)*dt;

% New position
sat.x(iter+1) = sat.x(iter)+sat.vx(iter)*dt;
sat.y(iter+1) = sat.y(iter)+sat.vy(iter)*dt;
sat.z(iter+1) = sat.z(iter)+sat.vz(iter)*dt;

% Resize control vector
sat.ux(iter+1) = 0;
sat.uy(iter+1) = 0;
sat.uz(iter+1) = 0;

% Propagate attitude
sat = attitudeProp(sat,scenario);

% Fuel mass loss
sat.fuel = sat.fuel-sum(u(1:6))*sat.umax*sat.mdot;
end

%% Propagate trajectory with no fuel
function sat = driftProp(sat,scenario)
dt = scenario.dt;

% Switch equations of motion model state matrix
switch sat.EOM
    case 'HCW'
        A = HCW(scenario);
    case 'LERM'
        A = LERM(scenario);
end

% Calculate new state
iter = length(sat.x);
X = [sat.x(iter),sat.y(iter),sat.z(iter),...
    sat.vx(iter),sat.vy(iter),sat.vz(iter)]';
DX = A*X;

% Control signals - all off
sat.ux(iter) = 0;
sat.uy(iter) = 0;
sat.uz(iter) = 0;

% New velocity
sat.vx(iter+1) = sat.vx(iter)+DX(4)*dt;
sat.vy(iter+1) = sat.vy(iter)+DX(5)*dt;
sat.vz(iter+1) = sat.vz(iter)+DX(6)*dt;

% New position
sat.x(iter+1) = sat.x(iter)+sat.vx(iter)*dt;
sat.y(iter+1) = sat.y(iter)+sat.vy(iter)*dt;
sat.z(iter+1) = sat.z(iter)+sat.vz(iter)*dt;

% Prop attitude
sat = attitudeProp(sat,scenario);

% Update control vector
sat.ux(iter+1) = 0;
sat.uy(iter+1) = 0;
sat.uz(iter+1) = 0;

% Debug flag 
sat.flag(iter) = 3;
end

%% Propagate attitude
function sat = attitudeProp(sat,scenario)
% Reaction wheel torques
iter = length(sat.q1);
dt = scenario.dt;

% Still in progress - use PD contorolled reaction wheel torques to point
% satellite at user-defined point.
% Else the satellite just minimizes divergence from the inertial axes.
if sat.point
%     vt = (sat.pt-sat.p)/norm(sat.pt-sat.p);
%     th3 = atan2(vt(2),vt(1));
%     th2 = atan2(vt(3),norm([vt(1),vt(2)]));
%     R = rot(th2,2)*rot(th3,3);
%     q4t = 1/2*sqrt(1+trace(R));
%     qt = 1/4/q4t*[R(2,3)-R(3,2);R(3,1)-R(1,3);R(1,2)-R(2,1)];
% 
%     Tx = -sat.kp*(sat.q1(iter)-qt(1))-sat.kd*sat.wb1(iter);
%     Ty = -sat.kp*(sat.q2(iter)-qt(2))-sat.kd*sat.wb2(iter);
%     Tz = -sat.kp*(sat.q3(iter)-qt(3))-sat.kd*sat.wb3(iter);   
else
    sat.T1(iter) = -sat.kp*(sat.q1(iter))-sat.kd*sat.wb1(iter);
    sat.T2(iter) = -sat.kp*(sat.q2(iter))-sat.kd*sat.wb2(iter);
    sat.T3(iter) = -sat.kp*(sat.q3(iter))-sat.kd*sat.wb3(iter);
    sat.T1(iter+1) = 0;
    sat.T2(iter+1) = 0;
    sat.T3(iter+1) = 0;
end

% Ensure torques are below max capable torque
if sat.T1(iter) > sat.Tmax,   sat.T1(iter) = sat.Tmax;  end
if sat.T1(iter) < -sat.Tmax,  sat.T1(iter) = -sat.Tmax; end
if sat.T2(iter) > sat.Tmax,   sat.T2(iter) = sat.Tmax;  end
if sat.T2(iter) < -sat.Tmax,  sat.T2(iter) = -sat.Tmax; end
if sat.T3(iter) > sat.Tmax,   sat.T3(iter) = sat.Tmax;  end
if sat.T3(iter) < -sat.Tmax,  sat.T3(iter) = -sat.Tmax; end

% Total applied torque with thruster offset moment
M(1) = sat.uz(iter)*sat.d(2)-sat.uy(iter)*sat.d(3)+sat.T1(iter);
M(2) = sat.ux(iter)*sat.d(3)-sat.uz(iter)*sat.d(1)+sat.T2(iter);
M(3) = sat.uy(iter)*sat.d(1)-sat.ux(iter)*sat.d(2)+sat.T3(iter);

% New angular velocity
I = sat.I;
w = sat.w;
sat.wb1(iter+1) = sat.wb1(iter)+((I(2)-I(3))/I(1)*w(2)*w(3)+M(1)/I(1))*dt;
sat.wb2(iter+1) = sat.wb2(iter)+((I(3)-I(1))/I(2)*w(1)*w(3)+M(2)/I(2))*dt;
sat.wb3(iter+1) = sat.wb3(iter)+((I(1)-I(2))/I(3)*w(1)*w(2)+M(3)/I(3))*dt;

% Unused, could be defined as euler angles if needed
% sat.th1(iter+1) = sat.th1(iter)+sat.wb1(iter)*dt;
% sat.th2(iter+1) = sat.th2(iter)+sat.wb2(iter)*dt;
% sat.th3(iter+1) = sat.th3(iter)+sat.wb3(iter)*dt;

% Solve for quaternion rate of change
q = sat.qb(1:3);
q4 = sat.qb(4);
qx = [0   -q(3) q(2)
      q(3) 0   -q(1)
     -q(2) q(1) 0];
dqdt = 1/2*[qx+q4*eye(3);-q']*w;

% Normalize quaternions to account for numerical error (Ensures quaternions
% don't diverge to unreal values.
qb = sat.qb+dqdt*dt;
qb = qb/norm(qb);

% New quaternions
sat.q1(iter+1) = qb(1);
sat.q2(iter+1) = qb(2);
sat.q3(iter+1) = qb(3);
sat.q4(iter+1) = qb(4);
end
##### SOURCE END #####
--></body></html>