
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>newSatellite</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-10-30"><meta name="DC.source" content="newSatellite.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">New Satellite</a></li><li><a href="#2">Default properties of a basic 6u cubesat</a></li><li><a href="#3">Graphics</a></li><li><a href="#4">Satellite parameters</a></li><li><a href="#5">Trajectory</a></li><li><a href="#6">Attitude</a></li><li><a href="#7">Solver</a></li><li><a href="#10">Basic point to point movement with collision avoidance</a></li><li><a href="#11">Hold within a certain zone</a></li><li><a href="#12">MPC Long-Range Maneuver</a></li><li><a href="#13">Equality contrainted LRM</a></li><li><a href="#14">Propagate with no control for given time</a></li><li><a href="#15">Convert solver signals to propagation</a></li><li><a href="#16">Propagate trajectory with no fuel</a></li><li><a href="#17">Propagate attitude</a></li><li><a href="#18">Plot relative trajectory</a></li><li><a href="#19">Plot control signals and state over time</a></li><li><a href="#20">Record a video of figure</a></li></ul></div><h2>New Satellite<a name="1"></a></h2><pre class="codeinput"><span class="keyword">classdef</span> newSatellite &lt; handle
</pre><h2>Default properties of a basic 6u cubesat<a name="2"></a></h2><pre class="codeinput">    properties
</pre><h2>Graphics<a name="3"></a></h2><pre class="codeinput">        name = <span class="string">'CubeSat'</span>            <span class="comment">%Satellite name</span>
        EOM = <span class="string">'LERM'</span>                 <span class="comment">%Relative motion model</span>
        mode = <span class="string">'approach'</span>           <span class="comment">%Satellite objective</span>
        color = <span class="string">'b'</span>                 <span class="comment">%Graph color</span>
</pre><h2>Satellite parameters<a name="4"></a></h2><pre class="codeinput">        umax = 0.25                 <span class="comment">%Thrust,                N</span>
        ISP = 150                   <span class="comment">%Specific impulse,      s</span>
        dryMass = 13                <span class="comment">%Dry mass,              kg</span>
        fuel = 0.5                  <span class="comment">%Fuel mass,             kg</span>
        vmax = 0.5                  <span class="comment">%Max velocity,          m/s</span>
        bnd = [0.1,0.3,0.2]         <span class="comment">%Satellite size,        m</span>
        Tmax = 0.25                 <span class="comment">%Max reaction torque</span>
        kp = 0.1                    <span class="comment">%Position damping</span>
        kd = 0.7                    <span class="comment">%Velocity damping</span>
        ki = 0.3                    <span class="comment">%Integral damping</span>
        d = [0,0,0]                 <span class="comment">%Thruster misalignment m</span>
</pre><h2>Trajectory<a name="5"></a></h2><pre class="codeinput">        t = 0
        x = 0                       <span class="comment">%x position over time,  m</span>
        y = 0                       <span class="comment">%y position over time,  m</span>
        z = 0                       <span class="comment">%z position over time,  m</span>
        vx = 0                      <span class="comment">%x velocity over time,  m/s</span>
        vy = 0                      <span class="comment">%y velocity over time,  m/s</span>
        vz = 0                      <span class="comment">%z velocity over time,  m/s</span>
        ux = []                     <span class="comment">%x thrust over time,    N</span>
        uy = []                     <span class="comment">%y thrust over time,    N</span>
        uz = []                     <span class="comment">%z thrust over time,    N</span>
        ub1 = []                    <span class="comment">%b1 thrust over time,   N</span>
        ub2 = []                    <span class="comment">%b2 thrust over time,   N</span>
        ub3 = []                    <span class="comment">%b3 thrust over time,   N</span>
        T1 = []                     <span class="comment">%x reaction torque,     N*m</span>
        T2 = []                     <span class="comment">%y reaction torque,     N*m</span>
        T3 = []                     <span class="comment">%z reaction torque,     N*m</span>
</pre><h2>Attitude<a name="6"></a></h2><pre class="codeinput">        wb1 = 0                     <span class="comment">%Angular velocity       rad/s</span>
        wb2 = 0                     <span class="comment">%over time,             rad/s</span>
        wb3 = 0                     <span class="comment">%                       rad/s</span>
        q1 = 0                      <span class="comment">%Quaternions</span>
        q2 = 0
        q3 = 0
        q4 = 1;                     <span class="comment">%Scalar</span>
        point = 0                   <span class="comment">%Attitude pointing y/n, binary</span>
        pt = [0,0,0]                <span class="comment">%Attitude point target, m</span>
</pre><h2>Solver<a name="7"></a></h2><pre class="codeinput">        u = []
        a = []
        J = []
        flag = []                   <span class="comment">%Exit flag</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
    properties (Dependent)
        m                           <span class="comment">%Total mass,            kg</span>
        mdot                        <span class="comment">%Mass flow rate,        kg/s</span>
        p                           <span class="comment">%Position vector,       m</span>
        v                           <span class="comment">%Velocity vector,       m/s</span>
        w                           <span class="comment">%Angular velocity,      rad/s</span>
        qb                          <span class="comment">%Quaternions vector,</span>
        Rib                         <span class="comment">%Rotation matrix b2i</span>
        Rbi                         <span class="comment">%Rotation matrix i2b</span>
        ubnd                        <span class="comment">%Upper bound,           m</span>
        lbnd                        <span class="comment">%Lower bound,           m</span>
        I                           <span class="comment">%Moments of Inertia,    kg/m^2</span>
    <span class="keyword">end</span>
    methods
</pre><pre class="codeinput">        <span class="comment">% Total mass (Dependent)</span>
        <span class="keyword">function</span> m = get.m(obj)
            m = obj.fuel(end)+obj.dryMass;
        <span class="keyword">end</span>
        <span class="comment">% Mass flow rate (Dependent)</span>
        <span class="keyword">function</span> mdot = get.mdot(obj)
            mdot = obj.umax/obj.ISP/9.81;
        <span class="keyword">end</span>
        <span class="comment">% Current position vector</span>
        <span class="keyword">function</span> p = get.p(obj)
            p = [obj.x(end),obj.y(end),obj.z(end)];
        <span class="keyword">end</span>
        <span class="comment">% Current velocity vector</span>
        <span class="keyword">function</span> v = get.v(obj)
            v = [obj.vx(end),obj.vy(end),obj.vz(end)];
        <span class="keyword">end</span>
        <span class="comment">% Current thrust vector</span>
        <span class="comment">% Current body-frame angular velocity</span>
        <span class="keyword">function</span> w = get.w(obj)
            w = [obj.wb1(end),obj.wb2(end),obj.wb3(end)]';
        <span class="keyword">end</span>
        <span class="comment">% Current quaternions</span>
        <span class="keyword">function</span> qb = get.qb(obj)
            qb = [obj.q1(end),obj.q2(end),obj.q3(end),obj.q4(end)]';
        <span class="keyword">end</span>
        <span class="comment">% Current intertial to body rotation matrix</span>
        <span class="keyword">function</span> Rbi = get.Rbi(obj)
            q = obj.qb(1:3);
            q4 = obj.qb(4);
            qx = [0   -q(3) q(2)
                  q(3) 0   -q(1)
                 -q(2) q(1) 0];
            Rbi = (q4^2-q'*q)*eye(3)+2*(q*q')-2*q4*qx;
        <span class="keyword">end</span>
        <span class="comment">% Current body to inertial rotation matrix</span>
        <span class="keyword">function</span> Rib = get.Rib(obj)
            Rib = transpose(obj.Rbi);
        <span class="keyword">end</span>
        <span class="comment">% Satellite body upper bound</span>
        <span class="keyword">function</span> ubnd = get.ubnd(obj)
            ubnd = obj.bnd/2;
        <span class="keyword">end</span>
        <span class="comment">% Satellite body lower lound</span>
        <span class="keyword">function</span> lbnd = get.lbnd(obj)
            lbnd = -obj.bnd/2;
        <span class="keyword">end</span>
        <span class="comment">% Satellite moment of inertia vector</span>
        <span class="keyword">function</span> I = get.I(obj)
            I(1) = 1/12*obj.m*(obj.bnd(2)^2+obj.bnd(3)^2);
            I(2) = 1/12*obj.m*(obj.bnd(1)^2+obj.bnd(3)^2);
            I(3) = 1/12*obj.m*(obj.bnd(1)^2+obj.bnd(2)^2);
        <span class="keyword">end</span>
</pre><pre class="codeoutput">  newSatellite with properties:

       name: 'CubeSat'
        EOM: 'LERM'
       mode: 'approach'
      color: 'b'
       umax: 0.2500
        ISP: 150
    dryMass: 13
       fuel: 0.5000
       vmax: 0.5000
        bnd: [0.1000 0.3000 0.2000]
       Tmax: 0.2500
         kp: 0.1000
         kd: 0.7000
         ki: 0.3000
          d: [0 0 0]
          t: 0
          x: 0
          y: 0
          z: 0
         vx: 0
         vy: 0
         vz: 0
         ux: []
         uy: []
         uz: []
        ub1: []
        ub2: []
        ub3: []
         T1: []
         T2: []
         T3: []
        wb1: 0
        wb2: 0
        wb3: 0
         q1: 0
         q2: 0
         q3: 0
         q4: 1
      point: 0
         pt: [0 0 0]
          u: []
          a: []
          J: []
       flag: []
          m: 13.5000
       mdot: 1.6989e-04
          p: [0 0 0]
          v: [0 0 0]
          w: [3x1 double]
         qb: [4x1 double]
        Rib: [3x3 double]
        Rbi: [3x3 double]
       ubnd: [0.0500 0.1500 0.1000]
       lbnd: [-0.0500 -0.1500 -0.1000]
          I: [0.1462 0.0563 0.1125]

</pre><h2>Basic point to point movement with collision avoidance<a name="10"></a></h2><pre class="codeinput">        <span class="keyword">function</span> sat = approach(sat,scenario,p,lbnd,ubnd)
            <span class="keyword">if</span> nargin &lt; 4 || isempty(lbnd)
                lbnd = [];
                ubnd = [];
            <span class="keyword">end</span>
            <span class="keyword">if</span> sat.fuel &gt; 0
                w1 = 5e-2; <span class="comment">%Thrust</span>
                w2 = 1;    <span class="comment">%Targeting</span>
                Nvar = scenario.Nvar;
                Neom = scenario.Neom;
                scenario.Nslack = 3;
                scenario.Nobj = size(lbnd,1);
                Nslack = scenario.Nslack;
                Nbi = scenario.Nbi;
                Ntotal = scenario.Ntotal;

                <span class="comment">% Function coefficients</span>
                f = [w1*scenario.dt*ones(Nvar,1); <span class="comment">%Control thrusts</span>
                    zeros(Neom,1);       <span class="comment">%HCW accelerations</span>
                    w2*ones(Nslack,1);        <span class="comment">%Target distance</span>
                    zeros(Nbi,1)];       <span class="comment">%Collision avoidance</span>

                <span class="comment">% Parameter bounds, lower &amp; upper</span>
                lb = [zeros(Nvar,1);   <span class="comment">%Control thrusts</span>
                    -inf*ones(Neom,1); <span class="comment">%HCW accelerations</span>
                    zeros(Nslack,1);        <span class="comment">%Target distance</span>
                    zeros(Nbi,1)];     <span class="comment">%Collision avoidance</span>

                ub = [ones(Nvar,1);   <span class="comment">%Control thrusts</span>
                    inf*ones(Neom,1); <span class="comment">%HCW accelerations</span>
                    inf*ones(Nslack,1);    <span class="comment">%Target distance</span>
                    ones(Nbi,1)];     <span class="comment">%Collision avoidance</span>

                <span class="comment">% Integer constraints</span>
                intcon = [1:Nvar,Nvar+Neom+3+1:Ntotal];

                <span class="comment">% Equality contraints</span>
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario);

                <span class="comment">% Inequality contraints</span>
                A = [];   b = [];
                [A,b] = minDistance(A,b,sat,scenario,p);
                [A,b] = maxVelocity(A,b,sat,scenario);

                <span class="keyword">for</span> ii = 1:size(lbnd,1)
                    [A,b] = addObstacle(A,b,sat,scenario,lbnd(ii,:),ubnd(ii,:),ii);
                <span class="keyword">end</span>

                iter = length(sat.x);
                options = optimoptions(@intlinprog,<span class="string">'Display'</span>,<span class="string">'None'</span>,<span class="string">'MaxTime'</span>,1);
                [U,fval,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub,options);

                <span class="keyword">if</span> isempty(U) == 1
                    sat.u = sat.u(7:end);
                    sat.a = sat.a(4:end);
                    sat.J(iter) = sat.J(iter-1);
                    sat.flag(iter) = 3;
                <span class="keyword">else</span>
                    sat.u = U(1:Nvar);
                    sat.a = U(Nvar+1:Nvar+Neom);
                    sat.J(iter) = fval;
                    sat.flag(iter) = exitflag;
                <span class="keyword">end</span>
                sat.signalsProp(scenario);
            <span class="keyword">else</span>
                sat.driftProp(scenario);
            <span class="keyword">end</span>
            sat.attitudeProp(scenario);
            sat.t(iter+1) = sat.t(iter)+scenario.dt;
        <span class="keyword">end</span>
</pre><h2>Hold within a certain zone<a name="11"></a></h2><pre class="codeinput">        <span class="keyword">function</span> sat = maintain(sat,scenario,lbnd,ubnd)
            <span class="keyword">if</span> sat.fuel &gt; 0
                scenario.Nslack = 0;s
                Nvar = scenario.Nvar;
                Neom = scenario.Neom;

                <span class="comment">% Function coefficients</span>
                f = [scenario.dt*ones(Nvar,1);  <span class="comment">%Control thrusts</span>
                    zeros(Neom,1)];              <span class="comment">%HCW accelerations</span>

                <span class="comment">% Parameter bounds, lower &amp; upper</span>
                lb = [zeros(Nvar,1)            <span class="comment">%Control thrusts</span>
                    -inf*ones(Neom,1)];         <span class="comment">%HCW accelerations</span>


                ub = [ones(Nvar,1);             <span class="comment">%Control thrusts</span>
                    inf*ones(Neom,1)];           <span class="comment">%HCW accelerations</span>

                <span class="comment">% Integer constraints</span>
                intcon = 1:Nvar;

                <span class="comment">% Equality contraints</span>
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario);

                <span class="comment">% Inequality contraints</span>
                A = [];   b = [];
                [A,b] = holdProximity(A,b,sat,scenario,lbnd,ubnd);
                [A,b] = maxVelocity(A,b,sat,scenario);

                iter = length(sat.x);
                options = optimoptions(@intlinprog,<span class="string">'Display'</span>,<span class="string">'None'</span>,<span class="string">'MaxTime'</span>,1);<span class="comment">%</span>
                [U,fval,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub,options);

                <span class="keyword">if</span> isempty(U) == 1
                    sat.u = sat.u(7:end);
                    sat.a = sat.a(4:end);
                    sat.J(iter) = sat.J(iter-1);
                    sat.flag(iter) = 3;
                <span class="keyword">else</span>
                    sat.u = U(1:Nvar);
                    sat.a = U(Nvar+1:end);
                    sat.J(iter) = fval;
                    sat.flag(iter) = exitflag;
                <span class="keyword">end</span>

                sat.signalsProp(scenario);
            <span class="keyword">else</span>
                sat.driftProp(scenario);
            <span class="keyword">end</span>
            sat.t(iter+1) = sat.t(iter)+scenario.dt;
            sat.attitudeProp(scenario);
        <span class="keyword">end</span>
</pre><h2>MPC Long-Range Maneuver<a name="12"></a></h2><pre class="codeinput">        <span class="keyword">function</span> sat = phaseManeuver(sat,scenario,Xf,tf,dtM)
            T0 = scenario.T;
            dt0 = scenario.dt;
            Nslack = 6;
            scenario.Nslack = Nslack;

            tt = 0;
            <span class="keyword">for</span> nn = 1:(tf/dtM)
                scenario.T = (tf-tt);
                scenario.dt = dtM;

                Nvar = scenario.Nvar;
                Neom = scenario.Neom;
                dt = scenario.dt;

                <span class="comment">% Optimization weights</span>
                w1 = 1e-2;          <span class="comment">%Control weight</span>
                w2 = 1;             <span class="comment">%Postion weight</span>
                w3 = 1e3;           <span class="comment">%Velocity weight</span>

                <span class="comment">% Function coefficients</span>
                f = [w1*dt*ones(Nvar,1) <span class="comment">%Control thrusts</span>
                    zeros(Neom,1)
                    w2*ones(Nslack/2,1)
                    w3*ones(Nslack/2,1)];

                <span class="comment">% Parameter bounds, lower &amp; upper</span>
                lb = [zeros(Nvar,1);   <span class="comment">%Control thrusts</span>
                     -inf*ones(Neom,1);
                      zeros(6,1)];

                ub = [ones(Nvar,1);   <span class="comment">%Control thrusts</span>
                      inf*ones(Neom,1);
                      1e5*ones(6,1)];

                <span class="comment">% Equality contraints</span>
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario,eye(3));

                <span class="comment">% Inequality contraints</span>
                A = [];   b = [];
                [A,b] = setPhaseState(A,b,sat,scenario,Xf);

                <span class="comment">% Integer constraint</span>
                intcon = [];

                <span class="comment">% options = optimoptions(@linprog);</span>
                [U,fval,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub);

                scenario.dt = dt0;

                <span class="keyword">if</span> isempty(U)
                    sat.propagate(scenario,(dtM/dt0));
                <span class="keyword">else</span>
                    <span class="keyword">for</span> ii = 1:(dtM/dt0)
                        iter = length(sat.x);
                        sat.J(iter) = fval;
                        sat.flag(iter) = exitflag;
                        sat.u(1:2:6) = sat.Rbi*U(1:2:6);
                        sat.u(2:2:6) = sat.Rbi*U(2:2:6);
                        sat.a = U(Nvar+1:Nvar+3);
                        sat = signalsProp(sat,scenario);
                        sat = attitudeProp(sat,scenario);
                        sat.t(iter+1) = sat.t(iter)+scenario.dt;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            scenario.T = T0;
        <span class="keyword">end</span>
</pre><h2>Equality contrainted LRM<a name="13"></a></h2><pre class="codeinput">        <span class="keyword">function</span> sat = phaseManeuver3(sat,scenario,Xf,tf,dtM)
            T0 = scenario.T;
            dt0 = scenario.dt;
            scenario.T = tf;
            scenario.dt = dtM;
            scenario.Nslack = 0;

            Nvar = scenario.Nvar;
            Neom = scenario.Neom;

            <span class="comment">% Function coefficients</span>
            f = [dtM*ones(Nvar,1) <span class="comment">%Control thrusts</span>
                 zeros(Neom,1)];

            <span class="comment">% Parameter bounds, lower &amp; upper</span>
            lb = [zeros(Nvar,1)   <span class="comment">%Control thrusts</span>
                 -inf*ones(Neom,1)];

            ub = [ones(Nvar,1);   <span class="comment">%Control thrusts</span>
                  inf*ones(Neom,1)];

            <span class="comment">% Equality contraints</span>
            Aeq = []; beq = [];
            [Aeq,beq] = setEOM(Aeq,beq,sat,scenario,eye(3));
            [Aeq,beq] = setPhaseStateEq(Aeq,beq,sat,scenario,Xf);

            <span class="comment">% Inequality contraints</span>
            A = [];   b = [];

            <span class="comment">% Integer constraint</span>
            intcon = [];

            <span class="comment">% options = optimoptions(@linprog);</span>
            [U,fval,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub);
            scenario.dt = dt0;
            scenario.T = T0;

            jj = 1;
            <span class="keyword">for</span> ii = 1:6:Nvar
                <span class="keyword">for</span> kk = 1:(dtM/dt0)
                    iter = length(sat.x);
                    sat.J(iter) = fval;
                    sat.flag(iter) = exitflag;

                    sat.u(1:2:6) = sat.Rbi*U(ii:2:ii+5);
                    sat.u(2:2:6) = sat.Rbi*U(ii+1:2:ii+5);
                    sat.a = U(Nvar+jj:Nvar+jj+2);

                    sat = signalsProp(sat,scenario);
                    sat = attitudeProp(sat,scenario);
                    sat.t(iter+1) = sat.t(iter)+scenario.dt;
                <span class="keyword">end</span>
                jj = jj+3;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>Propagate with no control for given time<a name="14"></a></h2><pre class="codeinput">        <span class="keyword">function</span> sat = propagate(sat,scenario,tspan)
            <span class="keyword">for</span> ii = 1:scenario.dt:tspan
                iter = length(sat.x);
                sat.J(iter) = 0;
                sat.flag(iter) = 0;
                sat.driftProp(scenario);
                sat.attitudeProp(scenario);
                sat.t(iter+1) = sat.t(iter)+scenario.dt;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>Convert solver signals to propagation<a name="15"></a></h2><pre class="codeinput">        <span class="keyword">function</span> sat = signalsProp(sat,scenario)
            u = sat.u;
            iter = length(sat.x);

            <span class="comment">% Control signals</span>
            ub = ([u(1)-u(2)
                   u(3)-u(4)
                   u(5)-u(6)]);
            ui = sat.Rib*ub;

            sat.ub1(iter) = sat.umax*ub(1);
            sat.ub2(iter) = sat.umax*ub(2);
            sat.ub3(iter) = sat.umax*ub(3);

            sat.ux(iter) = sat.umax*ui(1);
            sat.uy(iter) = sat.umax*ui(2);
            sat.uz(iter) = sat.umax*ui(3);

            ax = sat.a(1);
            ay = sat.a(2);
            az = sat.a(3);

<span class="comment">%             [dv,dx] = rk(sat,scenario);</span>
<span class="comment">%             sat.vx(iter+1) = sat.vx(iter)+dv(1);</span>
<span class="comment">%             sat.vy(iter+1) = sat.vy(iter)+dv(2);</span>
<span class="comment">%             sat.vz(iter+1) = sat.vz(iter)+dv(3);</span>
<span class="comment">%</span>
<span class="comment">%             % New position</span>
<span class="comment">%             sat.x(iter+1) = sat.x(iter)+dx(1);</span>
<span class="comment">%             sat.y(iter+1) = sat.y(iter)+dx(2);</span>
<span class="comment">%             sat.z(iter+1) = sat.z(iter)+dx(3);</span>


            <span class="comment">% New velocity</span>
            dt = scenario.dt;
            sat.vx(iter+1) = sat.vx(iter)+(sat.ux(iter)/sat.m+ax)*dt;
            sat.vy(iter+1) = sat.vy(iter)+(sat.uy(iter)/sat.m+ay)*dt;
            sat.vz(iter+1) = sat.vz(iter)+(sat.uz(iter)/sat.m+az)*dt;

            <span class="comment">% New position</span>
            sat.x(iter+1) = sat.x(iter)+sat.vx(iter)*dt;
            sat.y(iter+1) = sat.y(iter)+sat.vy(iter)*dt;
            sat.z(iter+1) = sat.z(iter)+sat.vz(iter)*dt;

            <span class="comment">% Resize control vector</span>
            sat.J(iter+1) = sat.J(iter);
            sat.ux(iter+1) = 0;
            sat.uy(iter+1) = 0;
            sat.uz(iter+1) = 0;
            sat.ub1(iter+1) = 0;
            sat.ub2(iter+1) = 0;
            sat.ub3(iter+1) = 0;

            <span class="comment">% Fuel mass loss</span>
            sat.fuel(iter+1) = sat.fuel(iter)-sum(abs(u(1:6)))*sat.mdot*dt;
        <span class="keyword">end</span>
</pre><h2>Propagate trajectory with no fuel<a name="16"></a></h2><pre class="codeinput">        <span class="keyword">function</span> sat = driftProp(sat,scenario)
            dt = scenario.dt;

            <span class="comment">% Switch equations of motion model state matrix</span>
            <span class="keyword">switch</span> sat.EOM
                <span class="keyword">case</span> <span class="string">'HCW'</span>
                    A = HCW(scenario);
                <span class="keyword">case</span> <span class="string">'LERM'</span>
                    A = LERM(scenario,sat.t(end));
            <span class="keyword">end</span>

            <span class="comment">% Calculate new state</span>
            iter = length(sat.x);
            sat.flag(iter) = 3;

            X = [sat.x(iter),sat.y(iter),sat.z(iter),<span class="keyword">...</span>
                sat.vx(iter),sat.vy(iter),sat.vz(iter)]';
            DX = A*X;


            <span class="comment">% Control signals - all off</span>
            sat.ub1(iter) = 0;
            sat.ub2(iter) = 0;
            sat.ub3(iter) = 0;

            sat.ux(iter) = 0;
            sat.uy(iter) = 0;
            sat.uz(iter) = 0;

            <span class="comment">% New velocity</span>
            sat.vx(iter+1) = sat.vx(iter)+DX(4)*dt;
            sat.vy(iter+1) = sat.vy(iter)+DX(5)*dt;
            sat.vz(iter+1) = sat.vz(iter)+DX(6)*dt;

            <span class="comment">% New position</span>
            sat.x(iter+1) = sat.x(iter)+sat.vx(iter)*dt;
            sat.y(iter+1) = sat.y(iter)+sat.vy(iter)*dt;
            sat.z(iter+1) = sat.z(iter)+sat.vz(iter)*dt;
<span class="comment">%             [dv,dx] = rk(sat,scenario);</span>
<span class="comment">%</span>
<span class="comment">%             % New velocity</span>
<span class="comment">%             sat.vx(iter+1) = sat.vx(iter)+dv(1);</span>
<span class="comment">%             sat.vy(iter+1) = sat.vy(iter)+dv(2);</span>
<span class="comment">%             sat.vz(iter+1) = sat.vz(iter)+dv(3);</span>
<span class="comment">%</span>
<span class="comment">%             % New position</span>
<span class="comment">%             sat.x(iter+1) = sat.x(iter)+dx(1);</span>
<span class="comment">%             sat.y(iter+1) = sat.y(iter)+dx(2);</span>
<span class="comment">%             sat.z(iter+1) = sat.z(iter)+dx(3);</span>

            <span class="comment">% Update control vector</span>
            sat.J(iter+1) = sat.J(iter);
            sat.ux(iter+1) = 0;
            sat.uy(iter+1) = 0;
            sat.uz(iter+1) = 0;

            sat.ub1(iter+1) = 0;
            sat.ub2(iter+1) = 0;
            sat.ub3(iter+1) = 0;

            <span class="comment">% Fuel</span>
            sat.fuel(iter+1) = sat.fuel(iter);


        <span class="keyword">end</span>
</pre><h2>Propagate attitude<a name="17"></a></h2><pre class="codeinput">        <span class="keyword">function</span> sat = attitudeProp(sat,scenario)
            <span class="comment">% Reaction wheel torques</span>
            iter = length(sat.q1);
            dt = scenario.dt;

            <span class="comment">% Uses PD contorolled reaction wheel torques to point</span>
            <span class="comment">% satellite at user-defined point.</span>
            <span class="comment">% Else the satellite just minimizes divergence from the</span>
            <span class="comment">% chief RIC axes.</span>
            <span class="keyword">if</span> sat.point
                vt = (sat.pt-sat.p)/norm(sat.pt-sat.p);
                th3 = -atan2(vt(2),vt(1));
                th2 = -atan2(vt(3),norm([vt(1),vt(2)]));
                R = rot(th3,3)*rot(th2,2);

                qr = zeros(4,1);
                qr(4) = 1/2*sqrt(1+trace(R))+1e-3;
                qr(1:3) = 1/(4*qr(4))*[R(2,3)-R(3,2);R(3,1)-R(1,3);R(1,2)-R(2,1)];
                qA = [qr(4)  qr(3) -qr(2) -qr(1)
                     -qr(3)  qr(4)  qr(1)  qr(2)
                      qr(2) -qr(1)  qr(4) -qr(3)
                      qr(1)  qr(2)  qr(3)  qr(4)];
                qe = qA*sat.qb;

                sat.T1(iter) = -sat.kp*(qe(1)*qe(4))-sat.kd*sat.wb1(iter);
                sat.T2(iter) = -sat.kp*(qe(2)*qe(4))-sat.kd*sat.wb2(iter);
                sat.T3(iter) = -sat.kp*(qe(3)*qe(4))-sat.kd*sat.wb3(iter);
                sat.T1(iter+1) = 0;
                sat.T2(iter+1) = 0;
                sat.T3(iter+1) = 0;
            <span class="keyword">else</span>
                sat.T1(iter) = -sat.kp*(sat.q1(iter))-sat.kd*sat.wb1(iter);
                sat.T2(iter) = -sat.kp*(sat.q2(iter))-sat.kd*sat.wb2(iter);
                sat.T3(iter) = -sat.kp*(sat.q3(iter))-sat.kd*sat.wb3(iter);
                sat.T1(iter+1) = 0;
                sat.T2(iter+1) = 0;
                sat.T3(iter+1) = 0;
            <span class="keyword">end</span>

            <span class="comment">% Ensure torques are below max capable torque</span>
            <span class="keyword">if</span> sat.T1(iter) &gt; sat.Tmax,   sat.T1(iter) = sat.Tmax;  <span class="keyword">end</span>
            <span class="keyword">if</span> sat.T1(iter) &lt; -sat.Tmax,  sat.T1(iter) = -sat.Tmax; <span class="keyword">end</span>
            <span class="keyword">if</span> sat.T2(iter) &gt; sat.Tmax,   sat.T2(iter) = sat.Tmax;  <span class="keyword">end</span>
            <span class="keyword">if</span> sat.T2(iter) &lt; -sat.Tmax,  sat.T2(iter) = -sat.Tmax; <span class="keyword">end</span>
            <span class="keyword">if</span> sat.T3(iter) &gt; sat.Tmax,   sat.T3(iter) = sat.Tmax;  <span class="keyword">end</span>
            <span class="keyword">if</span> sat.T3(iter) &lt; -sat.Tmax,  sat.T3(iter) = -sat.Tmax; <span class="keyword">end</span>

            <span class="comment">% Total applied torque with thruster offset moment</span>
            M(1) = sat.ub3(iter)*sat.d(2)-sat.ub2(iter)*sat.d(3)+sat.T1(iter);
            M(2) = sat.ub1(iter)*sat.d(3)-sat.ub3(iter)*sat.d(1)+sat.T2(iter);
            M(3) = sat.ub2(iter)*sat.d(1)-sat.ub1(iter)*sat.d(2)+sat.T3(iter);

            <span class="comment">% New angular velocity</span>
            I = sat.I;
            w = sat.w;
            sat.wb1(iter+1) = sat.wb1(iter)+((I(2)-I(3))/I(1)*w(2)*w(3)+M(1)/I(1))*dt;
            sat.wb2(iter+1) = sat.wb2(iter)+((I(3)-I(1))/I(2)*w(1)*w(3)+M(2)/I(2))*dt;
            sat.wb3(iter+1) = sat.wb3(iter)+((I(1)-I(2))/I(3)*w(1)*w(2)+M(3)/I(3))*dt;

            <span class="comment">% Solve for quaternion rate of change</span>
            q = sat.qb(1:3);
            q4 = sat.qb(4);
            qx = [0   -q(3) q(2)
                  q(3) 0   -q(1)
                 -q(2) q(1) 0];
            dqdt = 1/2*[qx+q4*eye(3);-q']*w;

            <span class="comment">% Normalize quaternions to account for numerical error (Ensures quaternions</span>
            <span class="comment">% don't diverge to unreal values.</span>
            qb = sat.qb+dqdt*dt;
            qb = qb/norm(qb);

            <span class="comment">% New quaternions</span>
            sat.q1(iter+1) = qb(1);
            sat.q2(iter+1) = qb(2);
            sat.q3(iter+1) = qb(3);
            sat.q4(iter+1) = qb(4);
        <span class="keyword">end</span>
</pre><h2>Plot relative trajectory<a name="18"></a></h2><pre class="codeinput">        <span class="keyword">function</span> plotTrajectory(sat,lbnd,ubnd,unit)
            <span class="keyword">if</span> nargin &lt; 2 || isempty(unit),unit = 5;<span class="keyword">end</span>
            fig = figure(1);

            <span class="comment">% Plot obstacle bounds</span>
            <span class="keyword">for</span> ii = 1:size(lbnd,1)
                plotObstacle(lbnd(ii,:),ubnd(ii,:),<span class="string">'-k'</span>);
            <span class="keyword">end</span>

            <span class="comment">% Plot satellite trajectory</span>
            hold <span class="string">on</span>
            <span class="keyword">for</span> jj = 1:length(sat)
                p1style = strcat(<span class="string">'-'</span>,sat.color);
                p4style = <span class="string">'ks'</span>;
                plot3(sat.y,sat.z,sat.x,p1style,<span class="string">'linewidth'</span>,1.5);
<span class="comment">%                 quiver3(sat.y,sat.z,sat.x,-sat.uy,-sat.uz,-sat.ux,1,'r','linewidth',1.5);</span>
                plot3(sat.p(2),sat.p(3),sat.p(1),p4style,<span class="string">'linewidth'</span>,2,<span class="string">'markersize'</span>,10);

                <span class="comment">% Plot satellite body axes</span>
                R = unit*sat.Rib;
                plot3([sat.p(2),sat.p(2)+R(2,1)'],[sat.p(3),sat.p(3)+R(3,1)'],<span class="keyword">...</span>
                    [sat.p(1),sat.p(1)+R(1,1)'],<span class="string">'b'</span>,<span class="string">'linewidth'</span>,1.5);
                plot3([sat.p(2),sat.p(2)+R(2,2)'],[sat.p(3),sat.p(3)+R(3,2)'],<span class="keyword">...</span>
                    [sat.p(1),sat.p(1)+R(1,2)'],<span class="string">'r'</span>,<span class="string">'linewidth'</span>,1.5);
                plot3([sat.p(2),sat.p(2)+R(2,3)'],[sat.p(3),sat.p(3)+R(3,3)'],<span class="keyword">...</span>
                    [sat.p(1),sat.p(1)+R(1,3)'],<span class="string">'g'</span>,<span class="string">'linewidth'</span>,1.5);
            <span class="keyword">end</span>
            hold <span class="string">off</span>

            <span class="comment">% Axis labels</span>
            grid <span class="string">on</span>
            zlabel(<span class="string">'Radial, x [m]'</span>)
            xlabel(<span class="string">'In-track, y [m]'</span>)
            ylabel(<span class="string">'Cross-track, z [m]'</span>)
            title(<span class="string">'Relative Trajectory'</span>)
            axis(<span class="string">'tight'</span>,<span class="string">'equal'</span>,<span class="string">'vis3d'</span>)
            camva(8)
            view(145,15)

            drawnow
        <span class="keyword">end</span>
</pre><h2>Plot control signals and state over time<a name="19"></a></h2><pre class="codeinput">        <span class="keyword">function</span> plotControls(sat)
            tf = sat.t(end);

            <span class="comment">%</span>
            figure
            subplot(3,3,1)
            hold <span class="string">on</span>
            stairs(sat.t,sat.ub1/sat.umax,<span class="string">'-b'</span>,<span class="string">'linewidth'</span>,2)
            plot([0 tf],[0 0],<span class="string">'--k'</span>,<span class="string">'linewidth'</span>,2)
            axis([0 tf -1.5 1.5])
            grid <span class="string">on</span>
            title(<span class="string">'Control Signals vs Time'</span>)
            ylabel(<span class="string">'ub1'</span>)

            subplot(3,3,4)
            hold <span class="string">on</span>
            stairs(sat.t,sat.ub2/sat.umax,<span class="string">'-r'</span>,<span class="string">'linewidth'</span>,2)
            plot([0 tf],[0 0],<span class="string">'--k'</span>,<span class="string">'linewidth'</span>,2)
            axis([0 tf -1.5 1.5])
            grid <span class="string">on</span>
            ylabel(<span class="string">'ub2'</span>)

            subplot(3,3,7)
            hold <span class="string">on</span>
            stairs(sat.t,sat.ub3/sat.umax,<span class="string">'-g'</span>,<span class="string">'linewidth'</span>,2)
            plot([0 tf],[0 0],<span class="string">'--k'</span>,<span class="string">'linewidth'</span>,2)
            axis([0 tf -1.5 1.5])
            grid <span class="string">on</span>
            xlabel(<span class="string">'Time [s]'</span>)
            ylabel(<span class="string">'ub3'</span>)

            <span class="comment">% Velocity</span>
            subplot(3,3,2)
            plot(sat.t,sat.vx,<span class="string">'-b'</span>,<span class="string">'linewidth'</span>,2)
            axis([0 tf 0 1],<span class="string">'auto y'</span>)
            grid <span class="string">on</span>
            ylabel(<span class="string">'Vx [m/s]'</span>)
            title(<span class="string">'Velocity vs Time'</span>)

            subplot(3,3,5)
            plot(sat.t,sat.vy,<span class="string">'-r'</span>,<span class="string">'linewidth'</span>,2)
            axis([0 tf 0 1],<span class="string">'auto y'</span>)
            grid <span class="string">on</span>
            ylabel(<span class="string">'Vy [m/s]'</span>)

            subplot(3,3,8)
            plot(sat.t,sat.vz,<span class="string">'-g'</span>,<span class="string">'linewidth'</span>,2)
            axis([0 tf 0 1],<span class="string">'auto y'</span>)
            grid <span class="string">on</span>
            xlabel(<span class="string">'Time [s]'</span>)
            ylabel(<span class="string">'Vz [m/s]'</span>)

            <span class="comment">% Position</span>
            subplot(3,3,3)
            plot(sat.t,sat.x,<span class="string">'-b'</span>,<span class="string">'linewidth'</span>,2)
            axis([0 tf 0 1],<span class="string">'auto y'</span>)
            grid <span class="string">on</span>
            ylabel(<span class="string">'x [m]'</span>)
            title(<span class="string">'Position vs Time'</span>)

            subplot(3,3,6)
            plot(sat.t,sat.y,<span class="string">'-r'</span>,<span class="string">'linewidth'</span>,2)
            axis([0 tf 0 1],<span class="string">'auto y'</span>)
            grid <span class="string">on</span>
            ylabel(<span class="string">'y [m]'</span>)

            subplot(3,3,9)
            plot(sat.t,sat.z,<span class="string">'-g'</span>,<span class="string">'linewidth'</span>,2)
            axis([0 tf 0 1],<span class="string">'auto y'</span>)
            grid <span class="string">on</span>
            xlabel(<span class="string">'Time [s]'</span>)
            ylabel(<span class="string">'z [m]'</span>)

            <span class="comment">%</span>
            figure
            subplot(3,1,1)
            hold <span class="string">on</span>
            plot(sat.t,sat.T1,<span class="string">'-b'</span>,<span class="string">'linewidth'</span>,2)
            plot(sat.t,sat.T2,<span class="string">'-r'</span>,<span class="string">'linewidth'</span>,2)
            plot(sat.t,sat.T3,<span class="string">'-g'</span>,<span class="string">'linewidth'</span>,2)
            hold <span class="string">off</span>
            axis([0 tf 0 1],<span class="string">'auto y'</span>)
            grid <span class="string">on</span>
            legend({<span class="string">'T1'</span>,<span class="string">'T2'</span>,<span class="string">'T3'</span>})
            xlabel(<span class="string">'Time [s]'</span>)
            ylabel(<span class="string">'Reaction Torques, Nm'</span>)
            title(<span class="string">'Reaction Torques vs Time'</span>)

            subplot(3,1,2)
            hold <span class="string">on</span>
            plot(sat.t,sat.wb1,<span class="string">'-b'</span>,<span class="string">'linewidth'</span>,2)
            plot(sat.t,sat.wb2,<span class="string">'-r'</span>,<span class="string">'linewidth'</span>,2)
            plot(sat.t,sat.wb3,<span class="string">'-g'</span>,<span class="string">'linewidth'</span>,2)
            hold <span class="string">off</span>
            axis([0 tf 0 1],<span class="string">'auto y'</span>)
            grid <span class="string">on</span>
            legend({<span class="string">'\omega1'</span>,<span class="string">'\omega2'</span>,<span class="string">'\omega3'</span>})
            xlabel(<span class="string">'Time [s]'</span>)
            ylabel(<span class="string">'Angular Velocity, rad/s'</span>)
            title(<span class="string">'Angular Velocity vs Time'</span>)

            subplot(3,1,3)
            hold <span class="string">on</span>
            plot(sat.t,sat.q1,<span class="string">'-b'</span>,<span class="string">'linewidth'</span>,2)
            plot(sat.t,sat.q2,<span class="string">'-r'</span>,<span class="string">'linewidth'</span>,2)
            plot(sat.t,sat.q3,<span class="string">'-g'</span>,<span class="string">'linewidth'</span>,2)
            plot(sat.t,sat.q4,<span class="string">'-k'</span>,<span class="string">'linewidth'</span>,2)
            hold <span class="string">off</span>
            axis([0 tf 0 1],<span class="string">'auto y'</span>)
            grid <span class="string">on</span>
            xlabel(<span class="string">'Time [s]'</span>)
            ylabel(<span class="string">'Quaternions'</span>)
            legend({<span class="string">'q1'</span>,<span class="string">'q2'</span>,<span class="string">'q3'</span>,<span class="string">'q4'</span>})
            title(<span class="string">'Attitude Quaternions vs Time'</span>)

            <span class="comment">%</span>
            figure
            subplot(4,1,1)
            hold <span class="string">on</span>
            stairs(sat.t,sat.ub1/sat.umax,<span class="string">'-k'</span>,<span class="string">'linewidth'</span>,1)
            plot([0 tf],[0 0],<span class="string">'--k'</span>,<span class="string">'linewidth'</span>,1)
            axis([0 tf -1.5 1.5])
            grid <span class="string">on</span>
            title(<span class="string">'Control Signals vs Time'</span>)
            xlabel(<span class="string">'Time [s]'</span>)
            ylabel(<span class="string">'u_{b1}'</span>)

            subplot(4,1,2)
            hold <span class="string">on</span>
            stairs(sat.t,sat.ub2/sat.umax,<span class="string">'-k'</span>,<span class="string">'linewidth'</span>,1)
            plot([0 tf],[0 0],<span class="string">'--k'</span>,<span class="string">'linewidth'</span>,1)
            axis([0 tf -1.5 1.5])
            grid <span class="string">on</span>
            xlabel(<span class="string">'Time [s]'</span>)
            ylabel(<span class="string">'u_{b2}'</span>)

            subplot(4,1,3)
            hold <span class="string">on</span>
            stairs(sat.t,sat.ub3/sat.umax,<span class="string">'-k'</span>,<span class="string">'linewidth'</span>,1)
            plot([0 tf],[0 0],<span class="string">'--k'</span>,<span class="string">'linewidth'</span>,1)
            axis([0 tf -1.5 1.5])
            grid <span class="string">on</span>
            xlabel(<span class="string">'Time [s]'</span>)
            ylabel(<span class="string">'u_{b3}'</span>)

            subplot(4,1,4)
            plot(sat.t,sat.J,<span class="string">'k'</span>,<span class="string">'linewidth'</span>,1)
            axis([0 tf 0 1],<span class="string">'auto y'</span>)
            grid <span class="string">on</span>
            xlabel(<span class="string">'Time [s]'</span>)
            ylabel(<span class="string">'Cost Function, J'</span>)

            figure
            plot(sat.t,sat.fuel,<span class="string">'k'</span>,<span class="string">'linewidth'</span>,1)
            axis([0 tf 0 sat.fuel(1)])
            grid <span class="string">on</span>
            xlabel(<span class="string">'Time [s]'</span>)
            ylabel(<span class="string">'Fuel, kg'</span>)
        <span class="keyword">end</span>
</pre><h2>Record a video of figure<a name="20"></a></h2><pre class="codeinput">        <span class="keyword">function</span> vid = renderVideo(sat,fileName,lbnd,ubnd,unit)
            close <span class="string">all</span>
            fig = figure(<span class="string">'Position'</span>,[100 100 1280 720]);

            satIter = newSatellite;
            vid = VideoWriter(fileName);
            vid.FrameRate = 60;
            vid.Quality = 100;
            open(vid);

            step = 10;
            <span class="keyword">for</span> ii = 1:step:length(sat.x)
                clf
                satIter.x = sat.x(1:ii);
                satIter.y = sat.y(1:ii);
                satIter.z = sat.z(1:ii);
                satIter.ux = sat.ux(1:ii);
                satIter.uy = sat.uy(1:ii);
                satIter.uz = sat.uz(1:ii);
                satIter.q1 = sat.q1(ii);
                satIter.q2 = sat.q2(ii);
                satIter.q3 = sat.q3(ii);
                satIter.q4 = sat.q4(ii);
                satIter.plotTrajectory(lbnd,ubnd,unit);
                frame = getframe(fig);
                writeVideo(vid,frame);
            <span class="keyword">end</span>
            close(vid);
            fprintf(<span class="string">'Done\n'</span>)
        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% New Satellite
classdef newSatellite < handle
    %% Default properties of a basic 6u cubesat
    properties
        %% Graphics
        name = 'CubeSat'            %Satellite name
        EOM = 'LERM'                 %Relative motion model
        mode = 'approach'           %Satellite objective
        color = 'b'                 %Graph color
        
        %% Satellite parameters
        umax = 0.25                 %Thrust,                N
        ISP = 150                   %Specific impulse,      s
        dryMass = 13                %Dry mass,              kg
        fuel = 0.5                  %Fuel mass,             kg
        vmax = 0.5                  %Max velocity,          m/s
        bnd = [0.1,0.3,0.2]         %Satellite size,        m
        Tmax = 0.25                 %Max reaction torque
        kp = 0.1                    %Position damping
        kd = 0.7                    %Velocity damping
        ki = 0.3                    %Integral damping
        d = [0,0,0]                 %Thruster misalignment m
        
        %% Trajectory
        t = 0
        x = 0                       %x position over time,  m
        y = 0                       %y position over time,  m
        z = 0                       %z position over time,  m
        vx = 0                      %x velocity over time,  m/s
        vy = 0                      %y velocity over time,  m/s
        vz = 0                      %z velocity over time,  m/s
        ux = []                     %x thrust over time,    N
        uy = []                     %y thrust over time,    N
        uz = []                     %z thrust over time,    N
        ub1 = []                    %b1 thrust over time,   N
        ub2 = []                    %b2 thrust over time,   N
        ub3 = []                    %b3 thrust over time,   N
        T1 = []                     %x reaction torque,     N*m
        T2 = []                     %y reaction torque,     N*m
        T3 = []                     %z reaction torque,     N*m
        
        %% Attitude
        wb1 = 0                     %Angular velocity       rad/s
        wb2 = 0                     %over time,             rad/s
        wb3 = 0                     %                       rad/s
        q1 = 0                      %Quaternions
        q2 = 0
        q3 = 0
        q4 = 1;                     %Scalar
        point = 0                   %Attitude pointing y/n, binary
        pt = [0,0,0]                %Attitude point target, m
        
        %% Solver
        u = []
        a = []
        J = []
        flag = []                   %Exit flag
        
    end
    properties (Dependent)
        m                           %Total mass,            kg
        mdot                        %Mass flow rate,        kg/s
        p                           %Position vector,       m
        v                           %Velocity vector,       m/s
        w                           %Angular velocity,      rad/s
        qb                          %Quaternions vector,
        Rib                         %Rotation matrix b2i
        Rbi                         %Rotation matrix i2b
        ubnd                        %Upper bound,           m
        lbnd                        %Lower bound,           m
        I                           %Moments of Inertia,    kg/m^2
    end
    methods
        % Total mass (Dependent)
        function m = get.m(obj)
            m = obj.fuel(end)+obj.dryMass;
        end
        % Mass flow rate (Dependent)
        function mdot = get.mdot(obj)
            mdot = obj.umax/obj.ISP/9.81;
        end
        % Current position vector
        function p = get.p(obj)
            p = [obj.x(end),obj.y(end),obj.z(end)];
        end
        % Current velocity vector
        function v = get.v(obj)
            v = [obj.vx(end),obj.vy(end),obj.vz(end)];
        end
        % Current thrust vector
        % Current body-frame angular velocity
        function w = get.w(obj)
            w = [obj.wb1(end),obj.wb2(end),obj.wb3(end)]';
        end
        % Current quaternions
        function qb = get.qb(obj)
            qb = [obj.q1(end),obj.q2(end),obj.q3(end),obj.q4(end)]';
        end
        % Current intertial to body rotation matrix
        function Rbi = get.Rbi(obj)
            q = obj.qb(1:3);
            q4 = obj.qb(4);
            qx = [0   -q(3) q(2)
                  q(3) 0   -q(1)
                 -q(2) q(1) 0];
            Rbi = (q4^2-q'*q)*eye(3)+2*(q*q')-2*q4*qx;
        end
        % Current body to inertial rotation matrix
        function Rib = get.Rib(obj)
            Rib = transpose(obj.Rbi);
        end
        % Satellite body upper bound
        function ubnd = get.ubnd(obj)
            ubnd = obj.bnd/2;
        end
        % Satellite body lower lound
        function lbnd = get.lbnd(obj)
            lbnd = -obj.bnd/2;
        end
        % Satellite moment of inertia vector
        function I = get.I(obj)
            I(1) = 1/12*obj.m*(obj.bnd(2)^2+obj.bnd(3)^2);
            I(2) = 1/12*obj.m*(obj.bnd(1)^2+obj.bnd(3)^2);
            I(3) = 1/12*obj.m*(obj.bnd(1)^2+obj.bnd(2)^2);
        end

        %% Basic point to point movement with collision avoidance
        function sat = approach(sat,scenario,p,lbnd,ubnd)
            if nargin < 4 || isempty(lbnd)
                lbnd = [];
                ubnd = [];
            end
            if sat.fuel > 0
                w1 = 5e-2; %Thrust
                w2 = 1;    %Targeting
                Nvar = scenario.Nvar;
                Neom = scenario.Neom;
                scenario.Nslack = 3;
                scenario.Nobj = size(lbnd,1);
                Nslack = scenario.Nslack;
                Nbi = scenario.Nbi;
                Ntotal = scenario.Ntotal;
                
                % Function coefficients
                f = [w1*scenario.dt*ones(Nvar,1); %Control thrusts
                    zeros(Neom,1);       %HCW accelerations
                    w2*ones(Nslack,1);        %Target distance
                    zeros(Nbi,1)];       %Collision avoidance
                
                % Parameter bounds, lower & upper
                lb = [zeros(Nvar,1);   %Control thrusts
                    -inf*ones(Neom,1); %HCW accelerations
                    zeros(Nslack,1);        %Target distance
                    zeros(Nbi,1)];     %Collision avoidance
                
                ub = [ones(Nvar,1);   %Control thrusts
                    inf*ones(Neom,1); %HCW accelerations
                    inf*ones(Nslack,1);    %Target distance
                    ones(Nbi,1)];     %Collision avoidance
                
                % Integer constraints
                intcon = [1:Nvar,Nvar+Neom+3+1:Ntotal];
                
                % Equality contraints
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario);
                
                % Inequality contraints
                A = [];   b = [];
                [A,b] = minDistance(A,b,sat,scenario,p);
                [A,b] = maxVelocity(A,b,sat,scenario);
                
                for ii = 1:size(lbnd,1)
                    [A,b] = addObstacle(A,b,sat,scenario,lbnd(ii,:),ubnd(ii,:),ii);
                end
                
                iter = length(sat.x);
                options = optimoptions(@intlinprog,'Display','None','MaxTime',1);
                [U,fval,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub,options);
                
                if isempty(U) == 1
                    sat.u = sat.u(7:end);
                    sat.a = sat.a(4:end);
                    sat.J(iter) = sat.J(iter-1);
                    sat.flag(iter) = 3;
                else
                    sat.u = U(1:Nvar);
                    sat.a = U(Nvar+1:Nvar+Neom);
                    sat.J(iter) = fval;
                    sat.flag(iter) = exitflag;
                end
                sat.signalsProp(scenario);
            else
                sat.driftProp(scenario);                
            end
            sat.attitudeProp(scenario);
            sat.t(iter+1) = sat.t(iter)+scenario.dt;
        end
        
        %% Hold within a certain zone
        function sat = maintain(sat,scenario,lbnd,ubnd)
            if sat.fuel > 0
                scenario.Nslack = 0;s
                Nvar = scenario.Nvar;
                Neom = scenario.Neom;
                               
                % Function coefficients
                f = [scenario.dt*ones(Nvar,1);  %Control thrusts
                    zeros(Neom,1)];              %HCW accelerations
                
                % Parameter bounds, lower & upper
                lb = [zeros(Nvar,1)            %Control thrusts
                    -inf*ones(Neom,1)];         %HCW accelerations

                
                ub = [ones(Nvar,1);             %Control thrusts
                    inf*ones(Neom,1)];           %HCW accelerations

                % Integer constraints
                intcon = 1:Nvar;
                
                % Equality contraints
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario);
                
                % Inequality contraints
                A = [];   b = [];
                [A,b] = holdProximity(A,b,sat,scenario,lbnd,ubnd);
                [A,b] = maxVelocity(A,b,sat,scenario);

                iter = length(sat.x);
                options = optimoptions(@intlinprog,'Display','None','MaxTime',1);%
                [U,fval,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub,options);
                
                if isempty(U) == 1
                    sat.u = sat.u(7:end);
                    sat.a = sat.a(4:end);
                    sat.J(iter) = sat.J(iter-1);
                    sat.flag(iter) = 3;
                else
                    sat.u = U(1:Nvar);
                    sat.a = U(Nvar+1:end);
                    sat.J(iter) = fval;
                    sat.flag(iter) = exitflag;
                end
                
                sat.signalsProp(scenario);
            else
                sat.driftProp(scenario);
            end
            sat.t(iter+1) = sat.t(iter)+scenario.dt;
            sat.attitudeProp(scenario);
        end
                
        %% MPC Long-Range Maneuver
        function sat = phaseManeuver(sat,scenario,Xf,tf,dtM)
            T0 = scenario.T;
            dt0 = scenario.dt;
            Nslack = 6;
            scenario.Nslack = Nslack;
            
            tt = 0;
            for nn = 1:(tf/dtM)
                scenario.T = (tf-tt);
                scenario.dt = dtM;
                
                Nvar = scenario.Nvar;
                Neom = scenario.Neom;
                dt = scenario.dt;
                
                % Optimization weights
                w1 = 1e-2;          %Control weight
                w2 = 1;             %Postion weight
                w3 = 1e3;           %Velocity weight
                
                % Function coefficients
                f = [w1*dt*ones(Nvar,1) %Control thrusts
                    zeros(Neom,1)
                    w2*ones(Nslack/2,1)
                    w3*ones(Nslack/2,1)];
                
                % Parameter bounds, lower & upper
                lb = [zeros(Nvar,1);   %Control thrusts
                     -inf*ones(Neom,1);
                      zeros(6,1)];
                
                ub = [ones(Nvar,1);   %Control thrusts
                      inf*ones(Neom,1);
                      1e5*ones(6,1)];
                
                % Equality contraints
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario,eye(3));
                
                % Inequality contraints
                A = [];   b = [];
                [A,b] = setPhaseState(A,b,sat,scenario,Xf);
                                
                % Integer constraint
                intcon = [];
                
                % options = optimoptions(@linprog);
                [U,fval,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub);
                
                scenario.dt = dt0;
                
                if isempty(U)
                    sat.propagate(scenario,(dtM/dt0));
                else
                    for ii = 1:(dtM/dt0)
                        iter = length(sat.x);
                        sat.J(iter) = fval;
                        sat.flag(iter) = exitflag;                
                        sat.u(1:2:6) = sat.Rbi*U(1:2:6);
                        sat.u(2:2:6) = sat.Rbi*U(2:2:6);
                        sat.a = U(Nvar+1:Nvar+3);
                        sat = signalsProp(sat,scenario);
                        sat = attitudeProp(sat,scenario);
                        sat.t(iter+1) = sat.t(iter)+scenario.dt;
                    end
                end
            end
            scenario.T = T0;
        end
   
        %% Equality contrainted LRM
        function sat = phaseManeuver3(sat,scenario,Xf,tf,dtM)
            T0 = scenario.T;
            dt0 = scenario.dt;
            scenario.T = tf;
            scenario.dt = dtM;
            scenario.Nslack = 0;
            
            Nvar = scenario.Nvar;
            Neom = scenario.Neom;
            
            % Function coefficients
            f = [dtM*ones(Nvar,1) %Control thrusts
                 zeros(Neom,1)];
            
            % Parameter bounds, lower & upper
            lb = [zeros(Nvar,1)   %Control thrusts
                 -inf*ones(Neom,1)];
            
            ub = [ones(Nvar,1);   %Control thrusts
                  inf*ones(Neom,1)];
            
            % Equality contraints
            Aeq = []; beq = [];
            [Aeq,beq] = setEOM(Aeq,beq,sat,scenario,eye(3));
            [Aeq,beq] = setPhaseStateEq(Aeq,beq,sat,scenario,Xf);
            
            % Inequality contraints
            A = [];   b = [];
            
            % Integer constraint
            intcon = [];
            
            % options = optimoptions(@linprog);
            [U,fval,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub);
            scenario.dt = dt0;
            scenario.T = T0;
            
            jj = 1;
            for ii = 1:6:Nvar
                for kk = 1:(dtM/dt0)
                    iter = length(sat.x);
                    sat.J(iter) = fval;
                    sat.flag(iter) = exitflag;
                    
                    sat.u(1:2:6) = sat.Rbi*U(ii:2:ii+5);
                    sat.u(2:2:6) = sat.Rbi*U(ii+1:2:ii+5);
                    sat.a = U(Nvar+jj:Nvar+jj+2);
                    
                    sat = signalsProp(sat,scenario);
                    sat = attitudeProp(sat,scenario);
                    sat.t(iter+1) = sat.t(iter)+scenario.dt;
                end
                jj = jj+3;
            end
        end
  
        %% Propagate with no control for given time
        function sat = propagate(sat,scenario,tspan)
            for ii = 1:scenario.dt:tspan
                iter = length(sat.x);
                sat.J(iter) = 0;
                sat.flag(iter) = 0;
                sat.driftProp(scenario);
                sat.attitudeProp(scenario);
                sat.t(iter+1) = sat.t(iter)+scenario.dt;
            end
        end
        
        %% Convert solver signals to propagation
        function sat = signalsProp(sat,scenario)
            u = sat.u;
            iter = length(sat.x);
            
            % Control signals
            ub = ([u(1)-u(2)
                   u(3)-u(4)
                   u(5)-u(6)]);
            ui = sat.Rib*ub;
            
            sat.ub1(iter) = sat.umax*ub(1);
            sat.ub2(iter) = sat.umax*ub(2);
            sat.ub3(iter) = sat.umax*ub(3);
            
            sat.ux(iter) = sat.umax*ui(1);
            sat.uy(iter) = sat.umax*ui(2);
            sat.uz(iter) = sat.umax*ui(3);
            
            ax = sat.a(1);
            ay = sat.a(2);
            az = sat.a(3);
            
%             [dv,dx] = rk(sat,scenario);
%             sat.vx(iter+1) = sat.vx(iter)+dv(1);
%             sat.vy(iter+1) = sat.vy(iter)+dv(2);
%             sat.vz(iter+1) = sat.vz(iter)+dv(3);
%             
%             % New position
%             sat.x(iter+1) = sat.x(iter)+dx(1);
%             sat.y(iter+1) = sat.y(iter)+dx(2);
%             sat.z(iter+1) = sat.z(iter)+dx(3);
            
            
            % New velocity
            dt = scenario.dt;
            sat.vx(iter+1) = sat.vx(iter)+(sat.ux(iter)/sat.m+ax)*dt;
            sat.vy(iter+1) = sat.vy(iter)+(sat.uy(iter)/sat.m+ay)*dt;
            sat.vz(iter+1) = sat.vz(iter)+(sat.uz(iter)/sat.m+az)*dt;     
            
            % New position
            sat.x(iter+1) = sat.x(iter)+sat.vx(iter)*dt;
            sat.y(iter+1) = sat.y(iter)+sat.vy(iter)*dt;
            sat.z(iter+1) = sat.z(iter)+sat.vz(iter)*dt;
             
            % Resize control vector
            sat.J(iter+1) = sat.J(iter);
            sat.ux(iter+1) = 0;
            sat.uy(iter+1) = 0;
            sat.uz(iter+1) = 0;
            sat.ub1(iter+1) = 0;
            sat.ub2(iter+1) = 0;
            sat.ub3(iter+1) = 0;
            
            % Fuel mass loss
            sat.fuel(iter+1) = sat.fuel(iter)-sum(abs(u(1:6)))*sat.mdot*dt;
        end
        
        %% Propagate trajectory with no fuel
        function sat = driftProp(sat,scenario)
            dt = scenario.dt;
            
            % Switch equations of motion model state matrix
            switch sat.EOM
                case 'HCW'
                    A = HCW(scenario);
                case 'LERM'
                    A = LERM(scenario,sat.t(end));
            end
            
            % Calculate new state
            iter = length(sat.x);
            sat.flag(iter) = 3;
            
            X = [sat.x(iter),sat.y(iter),sat.z(iter),...
                sat.vx(iter),sat.vy(iter),sat.vz(iter)]';
            DX = A*X;
            
           
            % Control signals - all off
            sat.ub1(iter) = 0;
            sat.ub2(iter) = 0;
            sat.ub3(iter) = 0;
            
            sat.ux(iter) = 0;
            sat.uy(iter) = 0;
            sat.uz(iter) = 0;
            
            % New velocity
            sat.vx(iter+1) = sat.vx(iter)+DX(4)*dt;
            sat.vy(iter+1) = sat.vy(iter)+DX(5)*dt;
            sat.vz(iter+1) = sat.vz(iter)+DX(6)*dt;
            
            % New position
            sat.x(iter+1) = sat.x(iter)+sat.vx(iter)*dt;
            sat.y(iter+1) = sat.y(iter)+sat.vy(iter)*dt;
            sat.z(iter+1) = sat.z(iter)+sat.vz(iter)*dt;
%             [dv,dx] = rk(sat,scenario);
%                         
%             % New velocity
%             sat.vx(iter+1) = sat.vx(iter)+dv(1);
%             sat.vy(iter+1) = sat.vy(iter)+dv(2);
%             sat.vz(iter+1) = sat.vz(iter)+dv(3);     
%             
%             % New position
%             sat.x(iter+1) = sat.x(iter)+dx(1);
%             sat.y(iter+1) = sat.y(iter)+dx(2);
%             sat.z(iter+1) = sat.z(iter)+dx(3);               

            % Update control vector
            sat.J(iter+1) = sat.J(iter);
            sat.ux(iter+1) = 0;
            sat.uy(iter+1) = 0;
            sat.uz(iter+1) = 0;
            
            sat.ub1(iter+1) = 0;
            sat.ub2(iter+1) = 0;
            sat.ub3(iter+1) = 0;
            
            % Fuel
            sat.fuel(iter+1) = sat.fuel(iter);
            
            
        end
        
        %% Propagate attitude
        function sat = attitudeProp(sat,scenario)
            % Reaction wheel torques
            iter = length(sat.q1);
            dt = scenario.dt;
            
            % Uses PD contorolled reaction wheel torques to point
            % satellite at user-defined point.
            % Else the satellite just minimizes divergence from the
            % chief RIC axes.  
            if sat.point
                vt = (sat.pt-sat.p)/norm(sat.pt-sat.p);
                th3 = -atan2(vt(2),vt(1));
                th2 = -atan2(vt(3),norm([vt(1),vt(2)]));
                R = rot(th3,3)*rot(th2,2);
                
                qr = zeros(4,1);
                qr(4) = 1/2*sqrt(1+trace(R))+1e-3;
                qr(1:3) = 1/(4*qr(4))*[R(2,3)-R(3,2);R(3,1)-R(1,3);R(1,2)-R(2,1)];
                qA = [qr(4)  qr(3) -qr(2) -qr(1)
                     -qr(3)  qr(4)  qr(1)  qr(2)
                      qr(2) -qr(1)  qr(4) -qr(3)
                      qr(1)  qr(2)  qr(3)  qr(4)];
                qe = qA*sat.qb;
                
                sat.T1(iter) = -sat.kp*(qe(1)*qe(4))-sat.kd*sat.wb1(iter);
                sat.T2(iter) = -sat.kp*(qe(2)*qe(4))-sat.kd*sat.wb2(iter);
                sat.T3(iter) = -sat.kp*(qe(3)*qe(4))-sat.kd*sat.wb3(iter);
                sat.T1(iter+1) = 0;
                sat.T2(iter+1) = 0;
                sat.T3(iter+1) = 0;
            else
                sat.T1(iter) = -sat.kp*(sat.q1(iter))-sat.kd*sat.wb1(iter);
                sat.T2(iter) = -sat.kp*(sat.q2(iter))-sat.kd*sat.wb2(iter);
                sat.T3(iter) = -sat.kp*(sat.q3(iter))-sat.kd*sat.wb3(iter);
                sat.T1(iter+1) = 0;
                sat.T2(iter+1) = 0;
                sat.T3(iter+1) = 0;
            end
            
            % Ensure torques are below max capable torque
            if sat.T1(iter) > sat.Tmax,   sat.T1(iter) = sat.Tmax;  end
            if sat.T1(iter) < -sat.Tmax,  sat.T1(iter) = -sat.Tmax; end
            if sat.T2(iter) > sat.Tmax,   sat.T2(iter) = sat.Tmax;  end
            if sat.T2(iter) < -sat.Tmax,  sat.T2(iter) = -sat.Tmax; end
            if sat.T3(iter) > sat.Tmax,   sat.T3(iter) = sat.Tmax;  end
            if sat.T3(iter) < -sat.Tmax,  sat.T3(iter) = -sat.Tmax; end
            
            % Total applied torque with thruster offset moment
            M(1) = sat.ub3(iter)*sat.d(2)-sat.ub2(iter)*sat.d(3)+sat.T1(iter);
            M(2) = sat.ub1(iter)*sat.d(3)-sat.ub3(iter)*sat.d(1)+sat.T2(iter);
            M(3) = sat.ub2(iter)*sat.d(1)-sat.ub1(iter)*sat.d(2)+sat.T3(iter);
            
            % New angular velocity
            I = sat.I;
            w = sat.w;
            sat.wb1(iter+1) = sat.wb1(iter)+((I(2)-I(3))/I(1)*w(2)*w(3)+M(1)/I(1))*dt;
            sat.wb2(iter+1) = sat.wb2(iter)+((I(3)-I(1))/I(2)*w(1)*w(3)+M(2)/I(2))*dt;
            sat.wb3(iter+1) = sat.wb3(iter)+((I(1)-I(2))/I(3)*w(1)*w(2)+M(3)/I(3))*dt;
            
            % Solve for quaternion rate of change
            q = sat.qb(1:3);
            q4 = sat.qb(4);
            qx = [0   -q(3) q(2)
                  q(3) 0   -q(1)
                 -q(2) q(1) 0];
            dqdt = 1/2*[qx+q4*eye(3);-q']*w;
            
            % Normalize quaternions to account for numerical error (Ensures quaternions
            % don't diverge to unreal values.
            qb = sat.qb+dqdt*dt;
            qb = qb/norm(qb);
            
            % New quaternions
            sat.q1(iter+1) = qb(1);
            sat.q2(iter+1) = qb(2);
            sat.q3(iter+1) = qb(3);
            sat.q4(iter+1) = qb(4);
        end
        
        %% Plot relative trajectory
        function plotTrajectory(sat,lbnd,ubnd,unit)
            if nargin < 2 || isempty(unit),unit = 5;end
            fig = figure(1);
            
            % Plot obstacle bounds
            for ii = 1:size(lbnd,1)
                plotObstacle(lbnd(ii,:),ubnd(ii,:),'-k');
            end
            
            % Plot satellite trajectory
            hold on
            for jj = 1:length(sat)
                p1style = strcat('-',sat.color);
                p4style = 'ks';
                plot3(sat.y,sat.z,sat.x,p1style,'linewidth',1.5);
%                 quiver3(sat.y,sat.z,sat.x,-sat.uy,-sat.uz,-sat.ux,1,'r','linewidth',1.5);
                plot3(sat.p(2),sat.p(3),sat.p(1),p4style,'linewidth',2,'markersize',10);
                
                % Plot satellite body axes
                R = unit*sat.Rib;
                plot3([sat.p(2),sat.p(2)+R(2,1)'],[sat.p(3),sat.p(3)+R(3,1)'],...
                    [sat.p(1),sat.p(1)+R(1,1)'],'b','linewidth',1.5);
                plot3([sat.p(2),sat.p(2)+R(2,2)'],[sat.p(3),sat.p(3)+R(3,2)'],...
                    [sat.p(1),sat.p(1)+R(1,2)'],'r','linewidth',1.5);
                plot3([sat.p(2),sat.p(2)+R(2,3)'],[sat.p(3),sat.p(3)+R(3,3)'],...
                    [sat.p(1),sat.p(1)+R(1,3)'],'g','linewidth',1.5);
            end
            hold off
            
            % Axis labels
            grid on
            zlabel('Radial, x [m]')
            xlabel('In-track, y [m]')
            ylabel('Cross-track, z [m]')
            title('Relative Trajectory')
            axis('tight','equal','vis3d')
            camva(8)
            view(145,15)
            
            drawnow
        end
        
        %% Plot control signals and state over time
        function plotControls(sat)
            tf = sat.t(end);
            
            %
            figure
            subplot(3,3,1)
            hold on
            stairs(sat.t,sat.ub1/sat.umax,'-b','linewidth',2)
            plot([0 tf],[0 0],'REPLACE_WITH_DASH_DASHk','linewidth',2)
            axis([0 tf -1.5 1.5])
            grid on
            title('Control Signals vs Time')
            ylabel('ub1')
            
            subplot(3,3,4)
            hold on
            stairs(sat.t,sat.ub2/sat.umax,'-r','linewidth',2)
            plot([0 tf],[0 0],'REPLACE_WITH_DASH_DASHk','linewidth',2)
            axis([0 tf -1.5 1.5])
            grid on
            ylabel('ub2')
            
            subplot(3,3,7)
            hold on
            stairs(sat.t,sat.ub3/sat.umax,'-g','linewidth',2)
            plot([0 tf],[0 0],'REPLACE_WITH_DASH_DASHk','linewidth',2)
            axis([0 tf -1.5 1.5])
            grid on
            xlabel('Time [s]')
            ylabel('ub3')
            
            % Velocity
            subplot(3,3,2)
            plot(sat.t,sat.vx,'-b','linewidth',2)
            axis([0 tf 0 1],'auto y')
            grid on
            ylabel('Vx [m/s]')
            title('Velocity vs Time')
            
            subplot(3,3,5)
            plot(sat.t,sat.vy,'-r','linewidth',2)
            axis([0 tf 0 1],'auto y')
            grid on
            ylabel('Vy [m/s]')
            
            subplot(3,3,8)
            plot(sat.t,sat.vz,'-g','linewidth',2)
            axis([0 tf 0 1],'auto y')
            grid on
            xlabel('Time [s]')
            ylabel('Vz [m/s]')
            
            % Position
            subplot(3,3,3)
            plot(sat.t,sat.x,'-b','linewidth',2)
            axis([0 tf 0 1],'auto y')
            grid on
            ylabel('x [m]')
            title('Position vs Time')
            
            subplot(3,3,6)
            plot(sat.t,sat.y,'-r','linewidth',2)
            axis([0 tf 0 1],'auto y')
            grid on
            ylabel('y [m]')
            
            subplot(3,3,9)
            plot(sat.t,sat.z,'-g','linewidth',2)
            axis([0 tf 0 1],'auto y')
            grid on
            xlabel('Time [s]')
            ylabel('z [m]')
            
            %
            figure
            subplot(3,1,1)
            hold on
            plot(sat.t,sat.T1,'-b','linewidth',2)
            plot(sat.t,sat.T2,'-r','linewidth',2)
            plot(sat.t,sat.T3,'-g','linewidth',2)
            hold off
            axis([0 tf 0 1],'auto y')
            grid on
            legend({'T1','T2','T3'})
            xlabel('Time [s]')
            ylabel('Reaction Torques, Nm')
            title('Reaction Torques vs Time')
            
            subplot(3,1,2)
            hold on
            plot(sat.t,sat.wb1,'-b','linewidth',2)
            plot(sat.t,sat.wb2,'-r','linewidth',2)
            plot(sat.t,sat.wb3,'-g','linewidth',2)
            hold off
            axis([0 tf 0 1],'auto y')
            grid on
            legend({'\omega1','\omega2','\omega3'})
            xlabel('Time [s]')
            ylabel('Angular Velocity, rad/s')
            title('Angular Velocity vs Time')
            
            subplot(3,1,3)
            hold on
            plot(sat.t,sat.q1,'-b','linewidth',2)
            plot(sat.t,sat.q2,'-r','linewidth',2)
            plot(sat.t,sat.q3,'-g','linewidth',2)
            plot(sat.t,sat.q4,'-k','linewidth',2)
            hold off
            axis([0 tf 0 1],'auto y')
            grid on
            xlabel('Time [s]')
            ylabel('Quaternions')
            legend({'q1','q2','q3','q4'})
            title('Attitude Quaternions vs Time')
            
            %
            figure
            subplot(4,1,1)
            hold on
            stairs(sat.t,sat.ub1/sat.umax,'-k','linewidth',1)
            plot([0 tf],[0 0],'REPLACE_WITH_DASH_DASHk','linewidth',1)
            axis([0 tf -1.5 1.5])
            grid on
            title('Control Signals vs Time')
            xlabel('Time [s]')
            ylabel('u_{b1}')
            
            subplot(4,1,2)
            hold on
            stairs(sat.t,sat.ub2/sat.umax,'-k','linewidth',1)
            plot([0 tf],[0 0],'REPLACE_WITH_DASH_DASHk','linewidth',1)
            axis([0 tf -1.5 1.5])
            grid on
            xlabel('Time [s]')
            ylabel('u_{b2}')
            
            subplot(4,1,3)
            hold on
            stairs(sat.t,sat.ub3/sat.umax,'-k','linewidth',1)
            plot([0 tf],[0 0],'REPLACE_WITH_DASH_DASHk','linewidth',1)
            axis([0 tf -1.5 1.5])
            grid on
            xlabel('Time [s]')
            ylabel('u_{b3}')
            
            subplot(4,1,4)
            plot(sat.t,sat.J,'k','linewidth',1)
            axis([0 tf 0 1],'auto y')
            grid on
            xlabel('Time [s]')
            ylabel('Cost Function, J')    
            
            figure
            plot(sat.t,sat.fuel,'k','linewidth',1)
            axis([0 tf 0 sat.fuel(1)])
            grid on
            xlabel('Time [s]')
            ylabel('Fuel, kg')
        end
        
        %% Record a video of figure
        function vid = renderVideo(sat,fileName,lbnd,ubnd,unit)
            close all
            fig = figure('Position',[100 100 1280 720]);
            
            satIter = newSatellite;
            vid = VideoWriter(fileName);
            vid.FrameRate = 60;
            vid.Quality = 100;
            open(vid);
            
            step = 10;
            for ii = 1:step:length(sat.x)
                clf
                satIter.x = sat.x(1:ii);
                satIter.y = sat.y(1:ii);
                satIter.z = sat.z(1:ii);
                satIter.ux = sat.ux(1:ii);
                satIter.uy = sat.uy(1:ii);
                satIter.uz = sat.uz(1:ii);
                satIter.q1 = sat.q1(ii);
                satIter.q2 = sat.q2(ii);
                satIter.q3 = sat.q3(ii);
                satIter.q4 = sat.q4(ii);
                satIter.plotTrajectory(lbnd,ubnd,unit);
                frame = getframe(fig);
                writeVideo(vid,frame);
            end
            close(vid);   
            fprintf('Done\n')
        end
    end
end
##### SOURCE END #####
--></body></html>