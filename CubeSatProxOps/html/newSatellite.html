
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>newSatellite</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-09-18"><meta name="DC.source" content="newSatellite.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Graphics</a></li><li><a href="#3">Satellite parameters</a></li><li><a href="#4">Trajectory</a></li><li><a href="#5">Attitude</a></li><li><a href="#6">Debug</a></li><li><a href="#9">Basic point to point movement with collision avoidance</a></li><li><a href="#10">Maximize distance from point with collision avoidance</a></li><li><a href="#11">Hold within a certain zone</a></li></ul></div><pre class="codeinput"><span class="comment">% Translational trajcetory generation is all the same as the summer.</span>
<span class="comment">% Organized to be more easily commanded. All attitude modeling is still in</span>
<span class="comment">% development. Basic damping and PD in included for perturbations caused</span>
<span class="comment">% from the off-centering of thrusters. As of 9/8 the model is not coupled</span>
<span class="comment">% with translational movement. The linearity of the model may limit the</span>
<span class="comment">% accuracy of coupling rotation with translation.</span>

<span class="keyword">classdef</span> newSatellite
    <span class="comment">%satellite defines the properties of a satellite as well as its trajectory</span>
    <span class="comment">% relative to the origin</span>

    <span class="comment">% Default properties of a basic cubesat</span>
    <span class="keyword">properties</span>
</pre><h2>Graphics<a name="2"></a></h2><pre class="codeinput">        name = <span class="string">'CubeSat'</span>            <span class="comment">%Satellite name</span>
        EOM = <span class="string">'HCW'</span>                 <span class="comment">%Relative motion model</span>
        mode = <span class="string">'approach'</span>           <span class="comment">%Satellite objective</span>
        color = <span class="string">'b'</span>                 <span class="comment">%Graph color</span>
</pre><h2>Satellite parameters<a name="3"></a></h2><pre class="codeinput">        umax = 0.25                 <span class="comment">%Thrust,                N</span>
        ISP = 150                   <span class="comment">%Specific impulse,      s</span>
        dryMass = 10                <span class="comment">%Dry mass,              kg</span>
        fuel = 0.5                  <span class="comment">%Fuel mass,             kg</span>
        vmax = 0.5                  <span class="comment">%Max velocity,          m/s</span>
        bnd = [0.1,0.1,0.1]         <span class="comment">%Satellite size,        m</span>
        Tmax = 0.25                 <span class="comment">%Max reaction torque</span>
        kp = 0.1                    <span class="comment">%Position damping</span>
        kd = 0.7                    <span class="comment">%Velocity damping</span>
        ki = 0.3                    <span class="comment">%Integral damping</span>
        dx = 0.01                   <span class="comment">%x-axis moment arm,     m</span>
        dy = 0.01                   <span class="comment">%y-axis moment arm,     m</span>
        dz = 0.01                   <span class="comment">%z-axis moment arm,     m</span>
</pre><h2>Trajectory<a name="4"></a></h2><pre class="codeinput">        x = 0                       <span class="comment">%x position over time,  m</span>
        y = 0                       <span class="comment">%y position over time,  m</span>
        z = 0                       <span class="comment">%z position over time,  m</span>
        vx = 0                      <span class="comment">%Velocity over time,    m/s</span>
        vy = 0                      <span class="comment">%                       m/s</span>
        vz = 0                      <span class="comment">%                       m/s</span>
        ux = 0                      <span class="comment">%Controls over time,    N</span>
        uy = 0                      <span class="comment">%                       N</span>
        uz = 0                      <span class="comment">%                       N</span>
</pre><h2>Attitude<a name="5"></a></h2><pre class="codeinput">        wb1 = 0                     <span class="comment">%Angular velocity       rad/s</span>
        wb2 = 0                     <span class="comment">%over time,             rad/s</span>
        wb3 = 0                     <span class="comment">%                       rad/s</span>
        th1 = 0
        th2 = 0
        th3 = 0
        q1 = 0
        q2 = 0
        q3 = 0
        q4 = 1;

        pointing = 0
        pt = [0,0,0]
</pre><h2>Debug<a name="6"></a></h2><pre class="codeinput">        flag = []                   <span class="comment">%Exit flag</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
    properties (Dependent)
        m                           <span class="comment">%Total mass,            kg</span>
        mdot                        <span class="comment">%Mass flow rate,        kg/s</span>
        p                           <span class="comment">%Position vector,       m</span>
        v                           <span class="comment">%Velocity vector,       m/s</span>
        w                           <span class="comment">%Angular velocity,</span>
        qb                          <span class="comment">%Quaternions</span>
        R                           <span class="comment">%Rotation matrix Rib</span>
        ubnd                        <span class="comment">%Upper bound,           m</span>
        lbnd                        <span class="comment">%Lower bound,           m</span>
        I                           <span class="comment">%Moments of Inertia,    kg/m^2</span>

    <span class="keyword">end</span>
    methods
</pre><pre class="codeinput">        <span class="comment">% Constructor</span>
        <span class="keyword">function</span> obj = satellite(umax,ISP,dryMass,fuel)
            <span class="keyword">if</span> nargin &gt; 0
                obj.umax = umax;
                obj.ISP = ISP;
                obj.dryMass = dryMass;
                obj.fuel = fuel;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Total mass (Dependent)</span>
        <span class="keyword">function</span> m = get.m(obj)
            m = obj.fuel+obj.dryMass;
        <span class="keyword">end</span>
        <span class="comment">% Mass flow rate (Dependent)</span>
        <span class="keyword">function</span> mdot = get.mdot(obj)
            mdot = 1/obj.ISP/9.81;
        <span class="keyword">end</span>
        <span class="keyword">function</span> p = get.p(obj)
            p = [obj.x(end),obj.y(end),obj.z(end)];
        <span class="keyword">end</span>
        <span class="keyword">function</span> v = get.v(obj)
            v = [obj.vx(end),obj.vy(end),obj.vz(end)];
        <span class="keyword">end</span>
        <span class="keyword">function</span> w = get.w(obj)
            w = [obj.wb1(end),obj.wb2(end),obj.wb3(end)]';
        <span class="keyword">end</span>
        <span class="keyword">function</span> qb = get.qb(obj)
            qb = [obj.q1(end),obj.q2(end),obj.q3(end),obj.q4(end)]';
        <span class="keyword">end</span>
        <span class="keyword">function</span> R = get.R(obj)
                q = obj.qb(1:3);
                q4 = obj.qb(4);
                qx = [0 -q(3) q(2)
                      q(3) 0 -q(1)
                     -q(2) q(1) 0];
                Rbi = (q4^2-q'*q)*eye(3)+2*(q*q')-2*q4*qx;
                R = Rbi';
        <span class="keyword">end</span>
        <span class="keyword">function</span> ubnd = get.ubnd(obj)
            ubnd = obj.bnd/2;
        <span class="keyword">end</span>
        <span class="keyword">function</span> lbnd = get.lbnd(obj)
            lbnd = -obj.bnd/2;
        <span class="keyword">end</span>
        <span class="keyword">function</span> I = get.I(obj)
            I(1) = 1/12*obj.m*(obj.bnd(2)^2+obj.bnd(3)^2);
            I(2) = 1/12*obj.m*(obj.bnd(1)^2+obj.bnd(3)^2);
            I(3) = 1/12*obj.m*(obj.bnd(1)^2+obj.bnd(2)^2);
        <span class="keyword">end</span>
</pre><h2>Basic point to point movement with collision avoidance<a name="9"></a></h2><pre class="codeinput">        <span class="keyword">function</span> sat = approach(sat,scenario,p,lbnd,ubnd)
            <span class="keyword">if</span> nargin &lt; 4 || isempty(lbnd)
                lbnd = [];
                ubnd = [];
            <span class="keyword">end</span>
            <span class="keyword">if</span> sat.fuel &gt; 0
                w1 = 1e-1; <span class="comment">%Thrust</span>
                w2 = 1;    <span class="comment">%Targeting</span>
                Nvar = scenario.Nvar;
                Neom = scenario.Neom;
                scenario.Nobj = size(lbnd,1);
                Nbi = scenario.Nbi;
                Ntotal = scenario.Ntotal;

                <span class="comment">% Function coefficients</span>
                f = [w1*scenario.dt*ones(Nvar,1); <span class="comment">%Control thrusts</span>
                    zeros(Neom,1);       <span class="comment">%HCW accelerations</span>
                    w2*ones(3,1);        <span class="comment">%Target distance</span>
                    zeros(Nbi,1)];       <span class="comment">%Collision avoidance</span>

                <span class="comment">% Parameter bounds, lower &amp; upper</span>
                lb = [zeros(Nvar,1);   <span class="comment">%Control thrusts</span>
                    -inf*ones(Neom,1); <span class="comment">%HCW accelerations</span>
                    zeros(3,1);        <span class="comment">%Target distance</span>
                    zeros(Nbi,1)];     <span class="comment">%Collision avoidance</span>

                ub = [ones(Nvar,1);   <span class="comment">%Control thrusts</span>
                    inf*ones(Neom,1); <span class="comment">%HCW accelerations</span>
                    inf*ones(3,1);    <span class="comment">%Target distance</span>
                    ones(Nbi,1)];     <span class="comment">%Collision avoidance</span>

                <span class="comment">% Integer constraints</span>
                intcon = [1:Nvar,Nvar+Neom+3+1:Ntotal];

                <span class="comment">% Equality contraints</span>
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario);

                <span class="comment">% Inequality contraints</span>
                A = [];   b = [];
                [A,b] = minDistance(A,b,sat,scenario,p);
                [A,b] = maxVelocity(A,b,sat,scenario);

                <span class="keyword">for</span> ii = 1:size(lbnd,1)
                    [A,b] = addObstacle(A,b,sat,scenario,lbnd(ii,:),ubnd(ii,:),ii);
                <span class="keyword">end</span>

                options = optimoptions(@intlinprog,<span class="string">'Display'</span>,<span class="string">'None'</span>,<span class="string">'MaxTime'</span>,1);
                [u,~,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub,options);

                sat = signalsProp(sat,scenario,u,exitflag);
            <span class="keyword">else</span>
                sat = driftProp(sat,scenario);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>Maximize distance from point with collision avoidance<a name="10"></a></h2><pre>       function sat = evade(sat,scenario,p)
       end</pre><h2>Hold within a certain zone<a name="11"></a></h2><pre class="codeinput">        <span class="keyword">function</span> sat = maintain(sat,scenario,lbnd,ubnd)
            <span class="keyword">if</span> sat.fuel &gt; 0
                Nvar = scenario.Nvar;
                Nhcw = scenario.Nhcw;

                <span class="comment">% Function coefficients</span>
                f = [scenario.dt*ones(Nvar,1);  <span class="comment">%Control thrusts</span>
                     zeros(Nhcw,1)              <span class="comment">%HCW accelerations</span>
                     zeros(3,1)];               <span class="comment">%Target distance</span>

                <span class="comment">% Parameter bounds, lower &amp; upper</span>
                lb = [zeros(Nvar,1);            <span class="comment">%Control thrusts</span>
                    -inf*ones(Nhcw,1)           <span class="comment">%HCW accelerations</span>
                     zeros(3,1)];

                ub = [ones(Nvar,1);             <span class="comment">%Control thrusts</span>
                     inf*ones(Nhcw,1)           <span class="comment">%HCW accelerations</span>
                     ones(3,1)];

                <span class="comment">% Integer constraints</span>
                intcon = 1:Nvar;

                <span class="comment">% Equality contraints</span>
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario);

                <span class="comment">% Inequality contraints</span>
                A = [];   b = [];
                [A,b] = holdProximity(A,b,sat,scenario,lbnd,ubnd);
                [A,b] = maxVelocity(A,b,sat,scenario);

                options = optimoptions(@intlinprog,<span class="string">'Display'</span>,<span class="string">'None'</span>,<span class="string">'MaxTime'</span>,1,<span class="keyword">...</span>
                    <span class="string">'RootLPMaxIterations'</span>,1e5);
                [u,~,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub,options);

                sat = signalsProp(sat,scenario,u,exitflag);
            <span class="keyword">else</span>
                sat = driftProp(sat,scenario);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> sat = signalsProp(sat,scenario,u,exitflag)
Nvar = scenario.Nvar;

iter = length(sat.x);
sat.flag(iter) = exitflag;

<span class="comment">% Control signals</span>
sat.ux(iter) = sat.umax*(u(1)-u(2));
sat.uy(iter) = sat.umax*(u(3)-u(4));
sat.uz(iter) = sat.umax*(u(5)-u(6));
ax = u(Nvar+1);
ay = u(Nvar+2);
az = u(Nvar+3);

<span class="comment">% New velocity</span>
dt = scenario.dt;
sat.vx(iter+1) = sat.vx(iter)+(sat.ux(iter)/sat.m+ax)*dt;
sat.vy(iter+1) = sat.vy(iter)+(sat.uy(iter)/sat.m+ay)*dt;
sat.vz(iter+1) = sat.vz(iter)+(sat.uz(iter)/sat.m+az)*dt;

<span class="comment">% New position</span>
sat.x(iter+1) = sat.x(iter)+sat.vx(iter)*dt;
sat.y(iter+1) = sat.y(iter)+sat.vy(iter)*dt;
sat.z(iter+1) = sat.z(iter)+sat.vz(iter)*dt;

sat.ux(iter+1) = 0;
sat.uy(iter+1) = 0;
sat.uz(iter+1) = 0;

<span class="comment">% Reaction wheel torques</span>


<span class="keyword">if</span> sat.pointing
    vt = (sat.pt-sat.p)/norm(sat.pt-sat.p);
    th3 = atan2(vt(2),vt(1));
    th2 = atan2(vt(3),norm([vt(1),vt(2)]));
    R = rot(th2,2)*rot(th3,3);
    q4t = 1/2*sqrt(1+trace(R));
    qt = 1/4/q4t*[R(2,3)-R(3,2);R(3,1)-R(1,3);R(1,2)-R(2,1)];

    Tx = -sat.kp*(sat.q1(iter)-qt(1))-sat.kd*sat.wb1(iter);
    Ty = -sat.kp*(sat.q2(iter)-qt(2))-sat.kd*sat.wb2(iter);
    Tz = -sat.kp*(sat.q3(iter)-qt(3))-sat.kd*sat.wb3(iter);
<span class="keyword">else</span>
    Tx = -sat.kp*(sat.q1(iter))-sat.kd*sat.wb1(iter);
    Ty = -sat.kp*(sat.q2(iter))-sat.kd*sat.wb2(iter);
    Tz = -sat.kp*(sat.q3(iter))-sat.kd*sat.wb3(iter);
<span class="keyword">end</span>

<span class="keyword">if</span> Tx &gt; sat.Tmax,   Tx = sat.Tmax;  <span class="keyword">end</span>
<span class="keyword">if</span> Tx &lt; -sat.Tmax,  Tx = -sat.Tmax; <span class="keyword">end</span>
<span class="keyword">if</span> Ty &gt; sat.Tmax,   Ty = sat.Tmax;  <span class="keyword">end</span>
<span class="keyword">if</span> Ty &lt; -sat.Tmax,  Ty = -sat.Tmax; <span class="keyword">end</span>
<span class="keyword">if</span> Tz &gt; sat.Tmax,   Tz = sat.Tmax;  <span class="keyword">end</span>
<span class="keyword">if</span> Tz &lt; -sat.Tmax,  Tz = -sat.Tmax; <span class="keyword">end</span>

<span class="comment">% Total applied torque</span>
M(1) = sat.uz(iter)*sat.dy-sat.uy(iter)*sat.dz+Tx;
M(2) = sat.ux(iter)*sat.dz-sat.uz(iter)*sat.dx+Ty;
M(3) = sat.uy(iter)*sat.dx-sat.ux(iter)*sat.dy+Tz;

<span class="comment">% New angular velocity</span>
I = sat.I;
w = sat.w;
sat.wb1(iter+1) = sat.wb1(iter)+((I(2)-I(3))/I(1)*w(2)*w(3)+M(1)/I(1))*dt;
sat.wb2(iter+1) = sat.wb2(iter)+((I(3)-I(1))/I(2)*w(1)*w(3)+M(2)/I(2))*dt;
sat.wb3(iter+1) = sat.wb3(iter)+((I(1)-I(2))/I(3)*w(1)*w(2)+M(3)/I(3))*dt;

sat.th1(iter+1) = sat.th1(iter)+sat.wb1(iter)*dt;
sat.th2(iter+1) = sat.th2(iter)+sat.wb2(iter)*dt;
sat.th3(iter+1) = sat.th3(iter)+sat.wb3(iter)*dt;

<span class="comment">% New quaternions</span>
q = sat.qb(1:3);
q4 = sat.qb(4);
qx = [0   -q(3) q(2)
      q(3) 0   -q(1)
     -q(2) q(1) 0];

dqdt = 1/2*[qx+q4*eye(3);-q']*w;
sat.q1(iter+1) = sat.q1(iter)+dqdt(1)*dt;
sat.q2(iter+1) = sat.q2(iter)+dqdt(2)*dt;
sat.q3(iter+1) = sat.q3(iter)+dqdt(3)*dt;
sat.q4(iter+1) = sat.q4(iter)+dqdt(4)*dt;

<span class="comment">% Fuel mass loss</span>
sat.fuel = sat.fuel-sum(u(1:6))*sat.umax*sat.mdot;
<span class="keyword">end</span>

<span class="comment">% No fuel - drift</span>
<span class="keyword">function</span> sat = driftProp(sat,scenario)
dt = scenario.dt;
<span class="keyword">switch</span> sat.EOM
    <span class="keyword">case</span> <span class="string">'HCW'</span>
        A = HCW(scenario);
    <span class="keyword">case</span> <span class="string">'LERM'</span>
        A = LERM(scenario);
<span class="keyword">end</span>
iter = length(sat.x);
X = [sat.x(iter),sat.y(iter),sat.z(iter),<span class="keyword">...</span>
    sat.vx(iter),sat.vy(iter),sat.vz(iter)]';
DX = A*X;

sat.ux(iter) = 0;
sat.uy(iter) = 0;
sat.uz(iter) = 0;
sat.vx(iter+1) = sat.vx(iter)+DX(4)*dt;
sat.vy(iter+1) = sat.vy(iter)+DX(5)*dt;
sat.vz(iter+1) = sat.vz(iter)+DX(6)*dt;
sat.x(iter+1) = sat.x(iter)+sat.vx(iter)*dt;
sat.y(iter+1) = sat.y(iter)+sat.vy(iter)*dt;
sat.z(iter+1) = sat.z(iter)+sat.vz(iter)*dt;
sat.ux(iter+1) = 0;
sat.uy(iter+1) = 0;
sat.uz(iter+1) = 0;
sat.flag(iter) = 3;
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
% Translational trajcetory generation is all the same as the summer.
% Organized to be more easily commanded. All attitude modeling is still in
% development. Basic damping and PD in included for perturbations caused
% from the off-centering of thrusters. As of 9/8 the model is not coupled
% with translational movement. The linearity of the model may limit the
% accuracy of coupling rotation with translation.

classdef newSatellite
    %satellite defines the properties of a satellite as well as its trajectory
    % relative to the origin
    
    % Default properties of a basic cubesat
    properties
        %% Graphics
        name = 'CubeSat'            %Satellite name
        EOM = 'HCW'                 %Relative motion model
        mode = 'approach'           %Satellite objective
        color = 'b'                 %Graph color
        
        %% Satellite parameters
        umax = 0.25                 %Thrust,                N
        ISP = 150                   %Specific impulse,      s
        dryMass = 10                %Dry mass,              kg
        fuel = 0.5                  %Fuel mass,             kg
        vmax = 0.5                  %Max velocity,          m/s
        bnd = [0.1,0.1,0.1]         %Satellite size,        m
        Tmax = 0.25                 %Max reaction torque
        kp = 0.1                    %Position damping
        kd = 0.7                    %Velocity damping
        ki = 0.3                    %Integral damping
        dx = 0.01                   %x-axis moment arm,     m
        dy = 0.01                   %y-axis moment arm,     m
        dz = 0.01                   %z-axis moment arm,     m
               
        %% Trajectory
        x = 0                       %x position over time,  m
        y = 0                       %y position over time,  m
        z = 0                       %z position over time,  m
        vx = 0                      %Velocity over time,    m/s
        vy = 0                      %                       m/s
        vz = 0                      %                       m/s
        ux = 0                      %Controls over time,    N
        uy = 0                      %                       N
        uz = 0                      %                       N
        
        %% Attitude
        wb1 = 0                     %Angular velocity       rad/s
        wb2 = 0                     %over time,             rad/s
        wb3 = 0                     %                       rad/s
        th1 = 0
        th2 = 0
        th3 = 0
        q1 = 0
        q2 = 0
        q3 = 0
        q4 = 1;

        pointing = 0
        pt = [0,0,0]
        
        %% Debug
        flag = []                   %Exit flag
        
    end
    properties (Dependent)
        m                           %Total mass,            kg
        mdot                        %Mass flow rate,        kg/s
        p                           %Position vector,       m
        v                           %Velocity vector,       m/s
        w                           %Angular velocity,
        qb                          %Quaternions
        R                           %Rotation matrix Rib
        ubnd                        %Upper bound,           m
        lbnd                        %Lower bound,           m
        I                           %Moments of Inertia,    kg/m^2
        
    end
    methods
        % Constructor
        function obj = satellite(umax,ISP,dryMass,fuel)
            if nargin > 0
                obj.umax = umax;
                obj.ISP = ISP;
                obj.dryMass = dryMass;
                obj.fuel = fuel;
            end
        end
        
        % Total mass (Dependent)
        function m = get.m(obj)
            m = obj.fuel+obj.dryMass;
        end
        % Mass flow rate (Dependent)
        function mdot = get.mdot(obj)
            mdot = 1/obj.ISP/9.81;
        end
        function p = get.p(obj)
            p = [obj.x(end),obj.y(end),obj.z(end)];
        end
        function v = get.v(obj)
            v = [obj.vx(end),obj.vy(end),obj.vz(end)];
        end
        function w = get.w(obj)
            w = [obj.wb1(end),obj.wb2(end),obj.wb3(end)]';
        end
        function qb = get.qb(obj)
            qb = [obj.q1(end),obj.q2(end),obj.q3(end),obj.q4(end)]';
        end
        function R = get.R(obj)
                q = obj.qb(1:3);
                q4 = obj.qb(4);
                qx = [0 -q(3) q(2)
                      q(3) 0 -q(1)
                     -q(2) q(1) 0];
                Rbi = (q4^2-q'*q)*eye(3)+2*(q*q')-2*q4*qx;
                R = Rbi';
        end
        function ubnd = get.ubnd(obj)
            ubnd = obj.bnd/2;
        end
        function lbnd = get.lbnd(obj)
            lbnd = -obj.bnd/2;
        end
        function I = get.I(obj)
            I(1) = 1/12*obj.m*(obj.bnd(2)^2+obj.bnd(3)^2);
            I(2) = 1/12*obj.m*(obj.bnd(1)^2+obj.bnd(3)^2);
            I(3) = 1/12*obj.m*(obj.bnd(1)^2+obj.bnd(2)^2);
        end      
        %% Basic point to point movement with collision avoidance
        function sat = approach(sat,scenario,p,lbnd,ubnd)
            if nargin < 4 || isempty(lbnd)
                lbnd = [];
                ubnd = [];
            end
            if sat.fuel > 0
                w1 = 1e-1; %Thrust
                w2 = 1;    %Targeting
                Nvar = scenario.Nvar;
                Neom = scenario.Neom;
                scenario.Nobj = size(lbnd,1);
                Nbi = scenario.Nbi;
                Ntotal = scenario.Ntotal;
                
                % Function coefficients
                f = [w1*scenario.dt*ones(Nvar,1); %Control thrusts
                    zeros(Neom,1);       %HCW accelerations
                    w2*ones(3,1);        %Target distance
                    zeros(Nbi,1)];       %Collision avoidance
                
                % Parameter bounds, lower & upper
                lb = [zeros(Nvar,1);   %Control thrusts
                    -inf*ones(Neom,1); %HCW accelerations
                    zeros(3,1);        %Target distance
                    zeros(Nbi,1)];     %Collision avoidance
                
                ub = [ones(Nvar,1);   %Control thrusts
                    inf*ones(Neom,1); %HCW accelerations
                    inf*ones(3,1);    %Target distance
                    ones(Nbi,1)];     %Collision avoidance
                
                % Integer constraints
                intcon = [1:Nvar,Nvar+Neom+3+1:Ntotal];
                
                % Equality contraints
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario);
                
                % Inequality contraints
                A = [];   b = [];
                [A,b] = minDistance(A,b,sat,scenario,p);
                [A,b] = maxVelocity(A,b,sat,scenario);
                
                for ii = 1:size(lbnd,1)
                    [A,b] = addObstacle(A,b,sat,scenario,lbnd(ii,:),ubnd(ii,:),ii);
                end

                options = optimoptions(@intlinprog,'Display','None','MaxTime',1);
                [u,~,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub,options);
                
                sat = signalsProp(sat,scenario,u,exitflag);
            else
                sat = driftProp(sat,scenario);
            end
        end
        
        %% Maximize distance from point with collision avoidance
%         function sat = evade(sat,scenario,p)
%         end
        
        %% Hold within a certain zone
        function sat = maintain(sat,scenario,lbnd,ubnd)
            if sat.fuel > 0
                Nvar = scenario.Nvar;
                Nhcw = scenario.Nhcw;
                
                % Function coefficients
                f = [scenario.dt*ones(Nvar,1);  %Control thrusts
                     zeros(Nhcw,1)              %HCW accelerations
                     zeros(3,1)];               %Target distance
                
                % Parameter bounds, lower & upper
                lb = [zeros(Nvar,1);            %Control thrusts
                    -inf*ones(Nhcw,1)           %HCW accelerations
                     zeros(3,1)];
                
                ub = [ones(Nvar,1);             %Control thrusts
                     inf*ones(Nhcw,1)           %HCW accelerations
                     ones(3,1)];    
                 
                % Integer constraints
                intcon = 1:Nvar;
                
                % Equality contraints
                Aeq = []; beq = [];
                [Aeq,beq] = setEOM(Aeq,beq,sat,scenario);
                
                % Inequality contraints
                A = [];   b = [];
                [A,b] = holdProximity(A,b,sat,scenario,lbnd,ubnd);
                [A,b] = maxVelocity(A,b,sat,scenario);
                
                options = optimoptions(@intlinprog,'Display','None','MaxTime',1,...
                    'RootLPMaxIterations',1e5);
                [u,~,exitflag] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub,options);
                
                sat = signalsProp(sat,scenario,u,exitflag);
            else
                sat = driftProp(sat,scenario);
            end
        end
    end
end

function sat = signalsProp(sat,scenario,u,exitflag)
Nvar = scenario.Nvar;

iter = length(sat.x);
sat.flag(iter) = exitflag;

% Control signals
sat.ux(iter) = sat.umax*(u(1)-u(2));
sat.uy(iter) = sat.umax*(u(3)-u(4));
sat.uz(iter) = sat.umax*(u(5)-u(6));
ax = u(Nvar+1);
ay = u(Nvar+2);
az = u(Nvar+3);

% New velocity
dt = scenario.dt;
sat.vx(iter+1) = sat.vx(iter)+(sat.ux(iter)/sat.m+ax)*dt;
sat.vy(iter+1) = sat.vy(iter)+(sat.uy(iter)/sat.m+ay)*dt;
sat.vz(iter+1) = sat.vz(iter)+(sat.uz(iter)/sat.m+az)*dt;

% New position
sat.x(iter+1) = sat.x(iter)+sat.vx(iter)*dt;
sat.y(iter+1) = sat.y(iter)+sat.vy(iter)*dt;
sat.z(iter+1) = sat.z(iter)+sat.vz(iter)*dt;

sat.ux(iter+1) = 0;
sat.uy(iter+1) = 0;
sat.uz(iter+1) = 0;

% Reaction wheel torques


if sat.pointing
    vt = (sat.pt-sat.p)/norm(sat.pt-sat.p);
    th3 = atan2(vt(2),vt(1));
    th2 = atan2(vt(3),norm([vt(1),vt(2)]));
    R = rot(th2,2)*rot(th3,3);
    q4t = 1/2*sqrt(1+trace(R));
    qt = 1/4/q4t*[R(2,3)-R(3,2);R(3,1)-R(1,3);R(1,2)-R(2,1)];

    Tx = -sat.kp*(sat.q1(iter)-qt(1))-sat.kd*sat.wb1(iter);
    Ty = -sat.kp*(sat.q2(iter)-qt(2))-sat.kd*sat.wb2(iter);
    Tz = -sat.kp*(sat.q3(iter)-qt(3))-sat.kd*sat.wb3(iter);   
else
    Tx = -sat.kp*(sat.q1(iter))-sat.kd*sat.wb1(iter);
    Ty = -sat.kp*(sat.q2(iter))-sat.kd*sat.wb2(iter);
    Tz = -sat.kp*(sat.q3(iter))-sat.kd*sat.wb3(iter);
end

if Tx > sat.Tmax,   Tx = sat.Tmax;  end
if Tx < -sat.Tmax,  Tx = -sat.Tmax; end
if Ty > sat.Tmax,   Ty = sat.Tmax;  end
if Ty < -sat.Tmax,  Ty = -sat.Tmax; end
if Tz > sat.Tmax,   Tz = sat.Tmax;  end
if Tz < -sat.Tmax,  Tz = -sat.Tmax; end

% Total applied torque
M(1) = sat.uz(iter)*sat.dy-sat.uy(iter)*sat.dz+Tx;
M(2) = sat.ux(iter)*sat.dz-sat.uz(iter)*sat.dx+Ty;
M(3) = sat.uy(iter)*sat.dx-sat.ux(iter)*sat.dy+Tz;

% New angular velocity
I = sat.I;
w = sat.w;
sat.wb1(iter+1) = sat.wb1(iter)+((I(2)-I(3))/I(1)*w(2)*w(3)+M(1)/I(1))*dt;
sat.wb2(iter+1) = sat.wb2(iter)+((I(3)-I(1))/I(2)*w(1)*w(3)+M(2)/I(2))*dt;
sat.wb3(iter+1) = sat.wb3(iter)+((I(1)-I(2))/I(3)*w(1)*w(2)+M(3)/I(3))*dt;

sat.th1(iter+1) = sat.th1(iter)+sat.wb1(iter)*dt;
sat.th2(iter+1) = sat.th2(iter)+sat.wb2(iter)*dt;
sat.th3(iter+1) = sat.th3(iter)+sat.wb3(iter)*dt;

% New quaternions
q = sat.qb(1:3);
q4 = sat.qb(4);
qx = [0   -q(3) q(2)
      q(3) 0   -q(1)
     -q(2) q(1) 0];
 
dqdt = 1/2*[qx+q4*eye(3);-q']*w;
sat.q1(iter+1) = sat.q1(iter)+dqdt(1)*dt;
sat.q2(iter+1) = sat.q2(iter)+dqdt(2)*dt;
sat.q3(iter+1) = sat.q3(iter)+dqdt(3)*dt;
sat.q4(iter+1) = sat.q4(iter)+dqdt(4)*dt;

% Fuel mass loss
sat.fuel = sat.fuel-sum(u(1:6))*sat.umax*sat.mdot;
end

% No fuel - drift
function sat = driftProp(sat,scenario)
dt = scenario.dt;
switch sat.EOM
    case 'HCW'
        A = HCW(scenario);
    case 'LERM'
        A = LERM(scenario);
end
iter = length(sat.x);
X = [sat.x(iter),sat.y(iter),sat.z(iter),...
    sat.vx(iter),sat.vy(iter),sat.vz(iter)]';
DX = A*X;

sat.ux(iter) = 0;
sat.uy(iter) = 0;
sat.uz(iter) = 0;
sat.vx(iter+1) = sat.vx(iter)+DX(4)*dt;
sat.vy(iter+1) = sat.vy(iter)+DX(5)*dt;
sat.vz(iter+1) = sat.vz(iter)+DX(6)*dt;
sat.x(iter+1) = sat.x(iter)+sat.vx(iter)*dt;
sat.y(iter+1) = sat.y(iter)+sat.vy(iter)*dt;
sat.z(iter+1) = sat.z(iter)+sat.vz(iter)*dt;
sat.ux(iter+1) = 0;
sat.uy(iter+1) = 0;
sat.uz(iter+1) = 0;
sat.flag(iter) = 3;
end
##### SOURCE END #####
--></body></html>